---
description: 
globs: 
alwaysApply: false
---
# Deployment & Infrastructure: YAML + Templates Cursor Rules Manager

## 1. Deployment Overview

The YAML + Templates Cursor Rules Manager is designed to be deployed in multiple ways to accommodate different team sizes, workflows, and integration needs. This document outlines the deployment architecture, infrastructure requirements, and operational considerations for successful implementation.

### 1.1 Deployment Models

The system supports three primary deployment models:

1. **Local Developer Installation**: Individual installation on developer machines
2. **Team Shared Repository**: Central repository shared by a team
3. **Enterprise Deployment**: Organization-wide deployment with CI/CD integration

Each model has different infrastructure requirements and operational considerations, detailed in the following sections.

### 1.2 Deployment Goals

The deployment architecture is designed with these goals:

- **Minimal Dependencies**: Few external dependencies for easy setup
- **Cross-Platform**: Works consistently across macOS, Windows, and Linux
- **Flexible Integration**: Integrates with existing developer workflows
- **Scalability**: Scales from individual developers to large organizations
- **Automation**: Supports automated deployment and updates

## 2. Local Developer Installation

### 2.1 Requirements

- **Node.js**: v18.x LTS or later
- **npm**: v8.x or later
- **Git**: v2.30.0 or later (optional, but recommended)
- **Disk Space**: ~100MB for installation

### 2.2 Installation Process

```bash
# Install globally via npm
npm install -g cursor-rules-manager

# Verify installation
cursor-rules-manager --version

# Initialize in project directory
cd my-project
cursor-rules-manager init
```

### 2.3 Configuration

Local installation stores configuration in the following locations:

- **Project Configuration**: `./.cursor-rules/` directory in each project
- **Global Configuration**: `~/.cursor-rules/` in user's home directory
- **Cache**: `~/.cursor-rules/cache/` for template compilation cache

### 2.4 Updates

Updates are managed through npm:

```bash
# Update to latest version
npm update -g cursor-rules-manager

# Update to specific version
npm install -g cursor-rules-manager@x.y.z
```

### 2.5 Local Developer Workflow

```bash
# Typical developer workflow
cursor-rules-manager init             # First-time setup
cursor-rules-manager build            # Generate rules
cursor-rules-manager watch            # Auto-rebuild on changes

# Link to project
ln -s $(pwd)/output/.cursor/rules/my-project..cursor/rules ../my-project/..cursor/rules
```

## 3. Team Shared Repository

### 3.1 Requirements

- **Shared Git Repository**: GitHub, GitLab, Bitbucket, etc.
- **Node.js**: v18.x LTS or later on all team members' machines
- **CI/CD**: Optional but recommended (GitHub Actions, GitLab CI, etc.)
- **Access Control**: Read/write permissions for team members

### 3.2 Repository Structure

```
team-cursor-rules/
├── config/                    # Configuration files
│   ├── shared/               # Team-wide standards
│   ├── frameworks/           # Framework rules
│   └── projects/             # Project configurations
├── templates/                 # Templates
│   ├── .cursor/rules/          # ..cursor/rules templates
│   ├── mdc/                  # MDC templates
│   └── html/                 # HTML templates
├── scripts/                   # Automation scripts
│   ├── setup-project.js      # Project setup wizard
│   ├── distribute.js         # Distribution script
│   └── hooks/                # Git hooks
├── output/                    # Generated files (may be gitignored)
├── package.json               # Dependencies and scripts
└── README.md                  # Documentation
```

### 3.3 Team Setup Process

```bash
# Clone the repository
git clone https://github.com/team/cursor-rules.git
cd cursor-rules

# Install dependencies
npm install

# Create new project configuration
npm run setup:project

# Build all projects
npm run build

# Distribute to team projects (using script)
npm run distribute
```

### 3.4 Automation with Git Hooks

```bash
# Setup Git hooks
npm run setup:hooks

# Hooks installed:
# - pre-commit: Validates configuration before commit
# - post-commit: Builds affected projects
# - post-merge: Builds all projects after pulling changes
```

### 3.5 Team Workflow Integration

```bash
# Add to team onboarding process
git clone https://github.com/team/cursor-rules.git
cd cursor-rules
npm install
npm run setup:project -- --name="new-project" --type="web_application"
npm run build -- --project="new-project"
npm run link -- --project="new-project" --target="../new-project"
```

## 4. Enterprise Deployment

### 4.1 Requirements

- **Centralized Repository**: Enterprise GitHub/GitLab instance
- **CI/CD Pipeline**: Automated build and deployment
- **Access Control**: Role-based access control
- **Monitoring**: Error tracking and usage analytics
- **Documentation**: Internal documentation and training

### 4.2 Infrastructure Components

#### 4.2.1 Repository Management

- **Monorepo Structure**: All configuration and templates in a single repository
- **Branch Protection**: Require reviews for main branch changes
- **Access Control**: Team-based access to specific directories

#### 4.2.2 CI/CD Pipeline

- **Automated Testing**: Test configurations and templates
- **Automated Building**: Build all projects on changes
- **Automated Distribution**: Update rules in all projects
- **Notification System**: Alert on build failures

#### 4.2.3 Centralized Configuration

- **Organization Standards**: Top-level configuration for all teams
- **Team Overrides**: Team-specific customizations
- **Project-Specific Rules**: Individual project requirements

### 4.3 Enterprise Setup Process

```bash
# Initial setup (by DevOps team)
git clone https://github.com/enterprise/cursor-rules.git
cd cursor-rules
npm install
npm run setup:enterprise

# Configure organization settings
npm run config:org -- --name="Enterprise Name" --defaults="path/to/defaults.yaml"

# Configure teams
npm run config:team -- --name="Frontend Team" --lead="lead@example.com"
npm run config:team -- --name="Backend Team" --lead="lead@example.com"

# Setup CI/CD
# - Configure GitHub Actions/GitLab CI
# - Setup distribution workflow
# - Configure notifications
```

### 4.4 Enterprise Workflow

```bash
# Adding a new project (via pull request process)
git checkout -b add-new-project
npm run setup:project -- --name="new-project" --team="Frontend Team"
git add config/projects/new-project.yaml
git commit -m "feat: add new-project configuration"
git push origin add-new-project
# Create pull request
# Code review
# Merge to main
# CI/CD automatically builds and distributes
```

### 4.5 Enterprise Scale Considerations

For large enterprises (50+ projects, multiple teams):

- **Partitioned Repositories**: Separate repositories per team with shared templates
- **Hierarchical Configuration**: Organization → Division → Team → Project
- **Approval Workflows**: Multi-level approval for changes
- **Automated Compliance**: Validate against organization standards
- **Metrics Dashboard**: Track rule compliance and usage

## 5. CI/CD Integration

### 5.1 GitHub Actions Integration

```yaml
# .github/workflows/build.yml
name: Build Cursor Rules

on:
  push:
    branches: [main]
    paths:
      - 'config/**'
      - 'templates/**'
  pull_request:
    branches: [main]
    paths:
      - 'config/**'
      - 'templates/**'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      - name: Install dependencies
        run: npm ci
      - name: Validate configuration
        run: npm run validate
      - name: Build all projects
        run: npm run build
      - name: Archive artifacts
        uses: actions/upload-artifact@v3
        with:
          name: cursor-rules
          path: output/
```

### 5.2 GitLab CI Integration

```yaml
# .gitlab-ci.yml
stages:
  - validate
  - build
  - deploy

validate:
  stage: validate
  image: node:18
  script:
    - npm ci
    - npm run validate
  rules:
    - changes:
        - config/**/*
        - templates/**/*

build:
  stage: build
  image: node:18
  script:
    - npm ci
    - npm run build
  artifacts:
    paths:
      - output/
  rules:
    - changes:
        - config/**/*
        - templates/**/*

deploy:
  stage: deploy
  image: node:18
  script:
    - npm ci
    - npm run distribute
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - config/**/*
        - templates/**/*
```

### 5.3 Circle CI Integration

```yaml
# .circleci/config.yml
version: 2.1
jobs:
  validate:
    docker:
      - image: cimg/node:18.0
    steps:
      - checkout
      - restore_cache:
          keys:
            - v1-dependencies-{{ checksum "package.json" }}
      - run: npm ci
      - save_cache:
          paths:
            - node_modules
          key: v1-dependencies-{{ checksum "package.json" }}
      - run: npm run validate

  build:
    docker:
      - image: cimg/node:18.0
    steps:
      - checkout
      - restore_cache:
          keys:
            - v1-dependencies-{{ checksum "package.json" }}
      - run: npm ci
      - run: npm run build
      - persist_to_workspace:
          root: .
          paths:
            - output

  deploy:
    docker:
      - image: cimg/node:18.0
    steps:
      - checkout
      - restore_cache:
          keys:
            - v1-dependencies-{{ checksum "package.json" }}
      - run: npm ci
      - attach_workspace:
          at: .
      - run: npm run distribute

workflows:
  cursor-rules:
    jobs:
      - validate
      - build:
          requires:
            - validate
      - deploy:
          requires:
            - build
          filters:
            branches:
              only: main
```

## 6. Infrastructure as Code

### 6.1 Docker Container

```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci --only=production

# Copy application
COPY . .

# Set up volume for output
VOLUME /app/output

# Set entrypoint
ENTRYPOINT ["npm", "run"]
CMD ["build"]
```

Usage:

```bash
# Build Docker image
docker build -t cursor-rules-manager .

# Run Docker container to build rules
docker run -v $(pwd)/output:/app/output cursor-rules-manager

# Run with specific command
docker run cursor-rules-manager validate
```

### 6.2 Kubernetes Deployment

```yaml
# kubernetes/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cursor-rules-manager
  labels:
    app: cursor-rules-manager
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cursor-rules-manager
  template:
    metadata:
      labels:
        app: cursor-rules-manager
    spec:
      containers:
      - name: cursor-rules-manager
        image: cursor-rules-manager:latest
        imagePullPolicy: Always
        command: ["npm", "run", "server"]
        ports:
        - containerPort: 3000
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
        - name: output-volume
          mountPath: /app/output
      volumes:
      - name: config-volume
        configMap:
          name: cursor-rules-config
      - name: output-volume
        persistentVolumeClaim:
          claimName: cursor-rules-output
```

### 6.3 AWS CDK Deployment

```typescript
// lib/cursor-rules-stack.ts
import * as cdk from 'aws-cdk-lib';
import * as s3 from 'aws-cdk-lib/aws-s3';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as apigateway from 'aws-cdk-lib/aws-apigateway';

export class CursorRulesStack extends cdk.Stack {
  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Storage for configuration and templates
    const configBucket = new s3.Bucket(this, 'ConfigBucket', {
      versioned: true,
      removalPolicy: cdk.RemovalPolicy.RETAIN,
    });

    // Storage for generated files
    const outputBucket = new s3.Bucket(this, 'OutputBucket', {
      websiteIndexDocument: 'index.html',
      publicReadAccess: true,
    });

    // Lambda function for building rules
    const builderFunction = new lambda.Function(this, 'BuilderFunction', {
      runtime: lambda.Runtime.NODEJS_18_X,
      handler: 'index.handler',
      code: lambda.Code.fromAsset('lambda'),
      environment: {
        CONFIG_BUCKET: configBucket.bucketName,
        OUTPUT_BUCKET: outputBucket.bucketName,
      },
      timeout: cdk.Duration.minutes(5),
      memorySize: 1024,
    });

    // Grant permissions
    configBucket.grantRead(builderFunction);
    outputBucket.grantReadWrite(builderFunction);

    // API Gateway
    const api = new apigateway.RestApi(this, 'CursorRulesApi', {
      restApiName: 'Cursor Rules API',
      description: 'API for building cursor rules',
    });

    const buildResource = api.root.addResource('build');
    const buildIntegration = new apigateway.LambdaIntegration(builderFunction);
    buildResource.addMethod('POST', buildIntegration);

    // Outputs
    new cdk.CfnOutput(this, 'ConfigBucketName', {
      value: configBucket.bucketName,
    });
    new cdk.CfnOutput(this, 'OutputBucketName', {
      value: outputBucket.bucketName,
    });
    new cdk.CfnOutput(this, 'ApiUrl', {
      value: api.url,
    });
  }
}
```

## 7. Monitoring and Logging

### 7.1 Logging Configuration

The system uses a structured logging approach with configurable outputs:

```typescript
// Configure logging for local development
Logger.configure({
  level: 'debug',
  format: 'text',
  destination: 'console',
  metadata: {
    environment: 'development',
    version: '1.0.0',
  },
});

// Configure logging for production
Logger.configure({
  level: 'info',
  format: 'json',
  destination: 'file',
  file: 'logs/cursor-rules.log',
  rotate: {
    maxFiles: 5,
    maxSize: '10MB',
  },
  metadata: {
    environment: 'production',
    version: '1.0.0',
  },
});
```

### 7.2 Monitoring Integration

The system can integrate with monitoring tools:

```typescript
// Sentry integration
import * as Sentry from '@sentry/node';

Sentry.init({
  dsn: 'https://your-sentry-dsn',
  environment: process.env.NODE_ENV,
  release: '1.0.0',
});

// Override error handler
process.on('unhandledRejection', (error) => {
  Sentry.captureException(error);
  console.error('Unhandled rejection:', error);
  process.exit(1);
});

// Application monitoring
import { Builder } from 'cursor-rules-manager';

const builder = new Builder();

builder.on('buildStarted', (project) => {
  Sentry.addBreadcrumb({
    category: 'build',
    message: `Build started for ${project.name}`,
    level: Sentry.Severity.Info,
  });
});

builder.on('buildError', (project, error) => {
  Sentry.captureException(error, {
    tags: {
      project: project.name,
    },
  });
});
```

### 7.3 Performance Monitoring

```typescript
// Performance monitoring
import { performance } from 'perf_hooks';

const start = performance.now();
await builder.buildAll();
const end = performance.now();

Logger.info('Build performance', {
  duration: end - start,
  projects: builder.projects.length,
});

// Detailed performance tracking
builder.on('buildStarted', (project) => {
  project.buildStartTime = performance.now();
});

builder.on('buildCompleted', (project) => {
  const duration = performance.now() - project.buildStartTime;
  Logger.info('Project build performance', {
    project: project.name,
    duration,
  });
  
  // Send metrics to monitoring system
  sendMetric('project_build_duration', duration, {
    project: project.name,
  });
});
```

## 8. Scaling Considerations

### 8.1 Vertical Scaling

For larger projects or organizations:

- **Memory Optimization**: Streaming for large files
- **CPU Optimization**: Parallel processing for builds
- **Disk Optimization**: Incremental builds and caching

Configuration options for vertical scaling:

```typescript
const builder = new Builder({
  concurrency: 4,                 // Number of parallel builds
  memoryLimit: 1024,              // Memory limit in MB
  incrementalBuilds: true,        // Enable incremental builds
  cache: {
    enabled: true,                // Enable caching
    directory: '.cache',          // Cache directory
    maxSize: 100 * 1024 * 1024,   // Max cache size (100MB)
  },
});
```

### 8.2 Horizontal Scaling

For enterprise deployments:

- **Distributed Builds**: Build different projects on different nodes
- **Shared Configuration**: Centralized configuration with distributed builds
- **Work Distribution**: Queue-based work distribution

Architecture for horizontal scaling:

```
                    ┌─────────────┐
                    │ API Gateway │
                    └──────┬──────┘
                           │
                    ┌──────┴──────┐
                    │  Build API  │
                    └──────┬──────┘
                           │
                ┌──────────┴───────────┐
                │                      │
        ┌───────┴────────┐    ┌────────┴──────┐
        │   Work Queue   │    │ Configuration │
        └───────┬────────┘    └────────┬──────┘
                │                      │
     ┌──────────┴──────────────┐      │
     │                         │      │
┌────┴─────┐  ┌────┴─────┐  ┌──┴───────┐
│ Worker 1 │  │ Worker 2 │  │ Worker 3 │
└──────────┘  └──────────┘  └──────────┘
```

### 8.3 Cloud Scaling

For serverless deployments:

- **Serverless Functions**: AWS Lambda/Azure Functions for builds
- **Object Storage**: S3/Blob Storage for configuration and output
- **CDN**: CloudFront/Akamai for distributing generated files

Serverless configuration example:

```yaml
# serverless.yml
service: cursor-rules-manager

provider:
  name: aws
  runtime: nodejs18.x
  region: us-east-1
  environment:
    CONFIG_BUCKET: ${self:custom.configBucket}
    OUTPUT_BUCKET: ${self:custom.outputBucket}
  iamRoleStatements:
    - Effect: Allow
      Action:
        - s3:GetObject
      Resource: "arn:aws:s3:::${self:custom.configBucket}/*"
    - Effect: Allow
      Action:
        - s3:PutObject
      Resource: "arn:aws:s3:::${self:custom.outputBucket}/*"

functions:
  build:
    handler: handler.build
    events:
      - http:
          path: build
          method: post
      - s3:
          bucket: ${self:custom.configBucket}
          event: s3:ObjectCreated:*
          rules:
            - prefix: config/

custom:
  configBucket: cursor-rules-config-${self:provider.stage}
  outputBucket: cursor-rules-output-${self:provider.stage}

resources:
  Resources:
    ConfigBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: ${self:custom.configBucket}
    OutputBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: ${self:custom.outputBucket}
        WebsiteConfiguration:
          IndexDocument: index.html
```

## 9. Backup and Recovery

### 9.1 Configuration Backup

```bash
# Export all configuration
cursor-rules-manager export --all --output backup/config.zip

# Restore from backup
cursor-rules-manager import --input backup/config.zip
```

### 9.2 Automated Backups

```yaml
# .github/workflows/backup.yml
name: Backup Configuration

on:
  schedule:
    - cron: '0 0 * * *'  # Daily at midnight

jobs:
  backup:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      - name: Install dependencies
        run: npm ci
      - name: Export configuration
        run: npm run export -- --all --output backup/config-$(date +%Y%m%d).zip
      - name: Upload backup
        uses: actions/upload-artifact@v3
        with:
          name: config-backup
          path: backup/config-*.zip
      - name: Upload to S3 (optional)
        run: aws s3 cp backup/config-$(date +%Y%m%d).zip s3://backup-bucket/
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
```

### 9.3 Disaster Recovery

```bash
# 1. Reinstall the tool
npm install -g cursor-rules-manager

# 2. Create empty repository
mkdir cursor-rules-recovery
cd cursor-rules-recovery
npm init -y

# 3. Restore from backup
cursor-rules-manager import --input backup/config.zip

# 4. Verify configuration
cursor-rules-manager validate

# 5. Rebuild all projects
cursor-rules-manager build
```

## 10. Security Considerations

### 10.1 Secure Configuration

```yaml
# Sensitive data handling in configuration
project:
  name: "secure-project"
  auth:
    # DON'T store secrets in configuration
    # api_key: "supersecret"  # BAD!
    
    # DO use environment variables
    api_key_env: "API_KEY"    # GOOD!
```

### 10.2 Access Control

For shared deployments:

- **File Permissions**: Appropriate permissions on configuration files
- **Repository Permissions**: Branch protection rules
- **API Authentication**: API keys or OAuth for API access

### 10.3 CI/CD Security

Security best practices for CI/CD:

- **Secret Management**: Use CI/CD platform's secret management
- **Minimal Permissions**: Principle of least privilege for CI/CD jobs
- **Dependency Scanning**: Regular scanning for vulnerabilities

```yaml
# GitHub Actions security
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      # Scan dependencies for vulnerabilities
      - name: Security scan
        uses: github/security-scan-action@v1
        
      # Use secrets securely
      - name: Deploy
        env:
          API_KEY: ${{ secrets.API_KEY }}
        run: npm run deploy
```

## 11. Implementation Roadmap

### 11.1 Phased Deployment

1. **Phase 1: Local Development**
   - Install tools on developer machines
   - Create initial configurations
   - Generate rules for a few projects

2. **Phase 2: Team Repository**
   - Set up shared repository
   - Migrate configurations
   - Configure CI/CD
   - Train team members

3. **Phase 3: Enterprise Integration**
   - Scale to all teams
   - Integrate with existing systems
   - Automate deployment
   - Monitor and optimize

### 11.2 Deployment Timeline

| Phase | Duration | Activities | Deliverables |
|-------|----------|------------|--------------|
| Setup | Week 1 | Tool installation, initial configuration | Working tool, sample project |
| Pilot | Weeks 2-3 | Configure a few key projects, test workflow | Project configurations, CI/CD |
| Rollout | Weeks 4-6 | Gradually add all projects, refine process | Complete configuration, documentation |
| Optimization | Ongoing | Monitor usage, refine templates | Performance improvements, training |

### 11.3 Deployment Checklist

Before full deployment:

- [ ] **Tool Installation**: Install on all required systems
- [ ] **Configuration Setup**: Create organization and team configurations
- [ ] **Template Development**: Create templates for all required formats
- [ ] **CI/CD Integration**: Set up automated builds and deployment
- [ ] **Documentation**: Create user and maintenance documentation
- [ ] **Training**: Train team members on usage and workflow
- [ ] **Monitoring**: Set up monitoring and logging
- [ ] **Backup**: Configure regular backups
- [ ] **Security Review**: Review security settings and permissions

## 12. Maintenance and Support

### 12.1 Routine Maintenance

```bash
# Regular maintenance tasks
npm run validate            # Validate all configurations
npm run update-dependencies # Update dependencies
npm run security-audit      # Check for security issues
npm run backup              # Create backup
```

### 12.2 Troubleshooting

Common issues and solutions:

- **Build Failures**: Check configuration validation, template errors
- **Distribution Issues**: Check file permissions, paths
- **Performance Problems**: Check for large files, template complexity

### 12.3 Support Resources

- **Documentation**: In-repository documentation
- **Issue Tracking**: GitHub/GitLab issues
- **Knowledge Base**: Internal wiki/documentation site
- **Support Channels**: Slack channel, email group

## 13. Conclusion

The YAML + Templates Cursor Rules Manager is designed for flexible deployment across a range of environments, from individual developers to large enterprises. The deployment architecture emphasizes:

- **Flexibility**: Multiple deployment models for different needs
- **Automation**: CI/CD integration for automated workflows
- **Scalability**: Vertical and horizontal scaling options
- **Security**: Secure configuration and access control
- **Maintainability**: Comprehensive monitoring and backup

By following the guidelines in this document, organizations can successfully deploy and maintain the system at their desired scale, ensuring consistent cursor rules across all projects with minimal manual effort.
