---
description: 
globs: 
alwaysApply: false
---
# Database Schema: YAML + Templates Cursor Rules Manager

## 1. Database Overview

The YAML + Templates Cursor Rules Manager primarily operates on the file system rather than using a traditional database. However, it does maintain structured data that can be conceptualized as a virtual database with specific schemas and relationships.

### 1.1 Data Storage Approach

Instead of a traditional database, the system uses:

- **File-based Storage**: YAML configuration files
- **Directory Structure**: Hierarchical organization of data
- **In-memory Processing**: Data loaded and processed in memory during operations

### 1.2 Data Organization Principles

The data is organized according to these principles:

- **Hierarchical Inheritance**: Organization → Team → Project → Individual files
- **Configuration Merging**: Child configurations override parent configurations
- **Source Control Integration**: All configuration and template files can be version-controlled
- **Schema Validation**: Configuration files are validated against JSON Schema definitions

## 2. Configuration Data Schema

### 2.1 Organization Configuration Schema

```yaml
# Schema for organization-level configuration (config/shared/organization.yaml)
organization:
  name: string                   # Organization name
  description: string            # Organization description
  defaults:
    frameworks: string[]         # Default frameworks
    rules:
      object                     # Global rule definitions
    output_formats: string[]     # Default output formats
    
  constants:
    object                       # Organization-wide constants

  templates:
    default: string              # Default template
    overrides: object            # Template overrides by project type
```

### 2.2 Team Configuration Schema

```yaml
# Schema for team-level configuration (config/teams/[team-name].yaml)
team:
  name: string                   # Team name
  description: string            # Team description
  lead: string                   # Team lead email/name
  members: number                # Team size
  
  preferences:
    frameworks: string[]         # Team-preferred frameworks
    tools: string[]              # Team-preferred tools
    rules:
      object                     # Team-specific rule overrides
  
  overrides:
    organization: object         # Team-specific overrides for org settings
```

### 2.3 Project Configuration Schema

```yaml
# Schema for project-level configuration (config/projects/[project-name].yaml)
project:
  name: string                   # Project name
  description: string            # Project description
  type: string                   # Project type (web_application, api_service, etc.)
  frameworks: string[]           # Project frameworks
  team: string                   # Associated team
  
  settings:
    strict_mode: boolean         # Whether to enforce strict rules
    performance_critical: boolean # Whether performance is critical
    security_critical: boolean   # Whether security is critical
    
  rules:
    object                       # Project-specific rule definitions
    
  build:
    template: string             # Template to use (overrides team/org defaults)
    output_formats: string[]     # Output formats
    output_path: string          # Custom output path
```

### 2.4 Framework Configuration Schema

```yaml
# Schema for framework-level configuration (config/frameworks/[framework-name].yaml)
framework:
  name: string                   # Framework name
  version: string                # Framework version range
  
  rules:
    components: object           # Component-related rules
    naming: object               # Naming conventions
    structure: object            # Structural requirements
    performance: object          # Performance recommendations
    testing: object              # Testing requirements
```

## 3. Virtual Entity Relationships

Though not stored in a relational database, the configuration data has conceptual relationships that can be modeled as entities and relationships.

### 3.1 Primary Entities

#### 3.1.1 Organization Entity

**Primary Key**: Name
**Description**: Top-level entity representing the organization's standards and defaults

#### 3.1.2 Team Entity

**Primary Key**: Name
**Foreign Keys**:
- Organization (Implicit)

**Description**: Represents a development team within the organization

#### 3.1.3 Project Entity

**Primary Key**: Name
**Foreign Keys**:
- Team (Explicit reference)
- Frameworks (Array of references)

**Description**: Represents a specific project with its configurations

#### 3.1.4 Framework Entity

**Primary Key**: Name
**Description**: Represents a technology framework with specific rules

### 3.2 Entity Relationships

#### 3.2.1 Organization-Team Relationship

**Type**: One-to-Many
**Description**: An organization has multiple teams
**Cardinality**: 1:N

#### 3.2.2 Team-Project Relationship

**Type**: One-to-Many
**Description**: A team manages multiple projects
**Cardinality**: 1:N

#### 3.2.3 Project-Framework Relationship

**Type**: Many-to-Many
**Description**: A project uses multiple frameworks, and frameworks are used by multiple projects
**Cardinality**: M:N

## 4. Data Access Patterns

### 4.1 Configuration Loading Flow

1. **Load Organization Config**:
   - Read organization.yaml
   - Validate against schema
   - Transform into base configuration object

2. **Load Team Config**:
   - Read team configuration based on project reference
   - Validate against schema
   - Merge with organization config (team overrides organization)

3. **Load Framework Configs**:
   - Read all framework configurations referenced by project
   - Validate each against schema
   - Prepare for inclusion in project context

4. **Load Project Config**:
   - Read project configuration
   - Validate against schema
   - Merge with team+organization config (project overrides team overrides organization)
   - Incorporate framework configurations

5. **Create Configuration Context**:
   - Combine all configurations into unified context
   - Resolve any placeholders or variables
   - Add computed properties
   - Prepare for template rendering

### 4.2 Common Query Patterns

#### 4.2.1 Get Project Configuration

```typescript
// Conceptual query to get fully-resolved project configuration
function getProjectConfiguration(projectId: string): ProjectConfiguration {
  const orgConfig = loadOrganizationConfig();
  const teamId = getTeamForProject(projectId);
  const teamConfig = loadTeamConfig(teamId);
  const projectConfig = loadProjectConfig(projectId);
  const frameworkIds = projectConfig.frameworks;
  const frameworkConfigs = loadFrameworkConfigs(frameworkIds);
  
  return mergeConfigurations(
    orgConfig,
    teamConfig,
    frameworkConfigs,
    projectConfig
  );
}
```

#### 4.2.2 Get Framework Rules

```typescript
// Conceptual query to get rules for a specific framework
function getFrameworkRules(frameworkId: string): FrameworkRules {
  const frameworkConfig = loadFrameworkConfig(frameworkId);
  return frameworkConfig.rules;
}
```

#### 4.2.3 Get Team Projects

```typescript
// Conceptual query to get all projects for a team
function getTeamProjects(teamId: string): Project[] {
  const allProjects = loadAllProjects();
  return allProjects.filter(project => project.team === teamId);
}
```

## 5. Data Integrity and Validation

### 5.1 Schema Validation

All configuration files are validated against JSON Schema definitions to ensure:

- Required fields are present
- Field types are correct
- Enum values are valid
- Field patterns match expected formats

### 5.2 Reference Integrity

The system validates references between entities:

- Project team references are checked against existing teams
- Framework references are checked against available frameworks
- Template references are checked against available templates

### 5.3 Inheritance Validation

When merging configurations through inheritance, the system:

- Ensures type compatibility between base and override values
- Validates that overrides conform to the expected schema
- Reports conflicts or invalid overrides

## 6. Data Migration and Evolution

### 6.1 Schema Versioning

The configuration schema includes versioning to allow for evolution:

```yaml
# Example of schema versioning
schema_version: "1.0"  # Configuration schema version
```

### 6.2 Migration Strategies

For schema evolution, the system supports:

1. **Backward Compatibility**: New versions can read old configurations
2. **Schema Migration**: Tool to update configurations to new schema
3. **Validation Warnings**: Deprecation warnings for outdated patterns

### 6.3 Data Backup

Since configurations are file-based:

1. **Git Integration**: Primary backup method is through version control
2. **Export Commands**: Commands to export configurations to archive
3. **Import Commands**: Commands to import configurations from archive

## 7. Performance Considerations

### 7.1 Data Loading Optimization

1. **Caching**:
   - Parse results cached in memory
   - File modification times tracked to avoid unnecessary reloading
   - Configuration context cached for repeated operations

2. **Lazy Loading**:
   - Framework configurations loaded only when needed
   - Template partials loaded on demand
   - Default configurations loaded once and reused

3. **Incremental Processing**:
   - Change detection to only process modified files
   - Dependency tracking to minimize cascading updates

### 7.2 Memory Management

1. **Efficient Data Structures**:
   - Optimized in-memory representations
   - Reference sharing for duplicate data
   - Garbage collection of unused configurations

2. **Streaming Processing**:
   - Process large files in chunks when possible
   - Stream template output for large files
   - Release resources after processing

## 8. Future Enhancements

### 8.1 Potential Database Integration

For future enterprise features, actual database integration could be added:

1. **Configuration Database**:
   - Store configurations in database for multi-user access
   - Support for access control and audit logging
   - Real-time collaboration features

2. **Metadata Database**:
   - Track build history and statistics
   - Store user preferences and settings
   - Maintain usage analytics

3. **Cache Database**:
   - Optimize build performance with persistent cache
   - Track dependencies for incremental builds
   - Store compiled templates and processed configurations

### 8.2 Extended Schema Features

Future schema enhancements could include:

1. **Advanced Validation**:
   - Custom validation rules beyond JSON Schema
   - Business logic validation
   - Cross-field and cross-entity validation

2. **Dynamic Configuration**:
   - Environment-specific configuration sections
   - Conditional configuration based on context
   - Runtime configuration generation

3. **Metadata Enrichment**:
   - User annotations and comments
   - Change history and tracking
   - Documentation links and references

## 9. Conclusion

While the YAML + Templates Cursor Rules Manager does not use a traditional database system, it implements a structured, schema-based approach to configuration data management. This provides many of the benefits of a database (validation, relationships, queries) while maintaining the simplicity and accessibility of file-based storage.

The hierarchical inheritance model allows for a clean separation of concerns:

- Organization-level: Global standards and defaults
- Team-level: Team preferences and adjustments
- Framework-level: Technology-specific rules and best practices
- Project-level: Project-specific requirements and customizations

This approach provides flexibility and extensibility while ensuring consistency and correctness through schema validation and structured processing.
