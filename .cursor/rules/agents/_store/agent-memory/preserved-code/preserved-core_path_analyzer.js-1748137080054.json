{
  "id": "preserved-core_path_analyzer.js-1748137080054",
  "type": "preserved-code",
  "content": "#!/usr/bin/env node\n\n/**\n * üîç Core Path Analyzer\n * \n * Comprehensive analyzer to detect corrupt, obsolete, and broken path patterns\n * in .cursor/rules/agents/_store/projects/_core content after migration\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\n\nclass CorePathAnalyzer {\n  constructor() {\n    this.coreDir = '.cursor/rules/agents/_store/projects/_core';\n    this.rulesDir = path.join(this.coreDir, 'rules');\n    this.results = {\n      totalFiles: 0,\n      corruptPaths: [],\n      obsoletePaths: [],\n      brokenLinks: [],\n      selfReferences: [],\n      missingFiles: [],\n      summary: {\n        totalIssues: 0,\n        criticalIssues: 0,\n        mediumIssues: 0,\n        lowIssues: 0\n      }\n    };\n    \n    // Pattern definitions for detection\n    this.patterns = {\n      // Obsolete .cursor patterns that should have been migrated\n      obsoleteCursor: [\n        /\\.cursor\\/rules\\/[^\\s\\)\\]\\,\\;]+/g,\n        /\\[([^\\]]+)\\]\\(\\.cursor\\/rules\\/([^)]+)\\)/g,\n        /`\\.cursor\\/rules\\/([^`]+)`/g\n      ],\n      \n      // Broken absolute paths\n      brokenAbsolute: [\n        /.cursor/rules/agents\\/_store\\/projects\\/_core\\/rules\\/[^\\s\\)\\]\\,\\;]+/g,\n        /\\[([^\\]]+)\\]\\(.cursor/rules/agents\\/_store\\/projects\\/_core\\/rules\\/([^)]+)\\)/g\n      ],\n      \n      // Self-referential patterns\n      selfReference: [\n        /\\[([^\\]]*?)\\]\\([^)]*?{filename}\\)/g,\n        /\\[{filename}\\]/g,\n        /\\[[^\\]]*\\]\\(\\s*\\)/g\n      ],\n      \n      // Broken markdown link formats\n      brokenLinks: [\n        /\\[([^\\]]+)\\]\\(\\s*\\)/g,\n        /\\]\\([0-9]+\\)/g,\n        /\\[[0-9]+\\]/g,\n        /\\[filename\\.mdc\\]/g,\n        /\\[t\\.mdc\\]/g\n      ],\n      \n      // Redundant path patterns\n      redundantPaths: [\n        /\\/\\.\\//g,\n        /\\/\\/+/g,\n        /\\.\\.\\//g,\n        /([^\\/])\\/\\/+/g\n      ]\n    };\n  }\n\n  /**\n   * Run comprehensive analysis\n   */\n  async analyze() {\n    console.log('üîç CORE PATH ANALYZER');\n    console.log('‚îÅ'.repeat(60));\n    console.log(`üìÅ Analyzing: ${this.coreDir}`);\n    console.log('');\n\n    try {\n      // Get all .mdc files\n      const mdcFiles = await this.getAllMdcFiles();\n      console.log(`üìÑ Found ${mdcFiles.length} .mdc files to analyze`);\n      console.log('');\n\n      // Analyze each file\n      for (const filePath of mdcFiles) {\n        await this.analyzeFile(filePath);\n      }\n\n      // Generate comprehensive report\n      await this.generateReport();\n      \n      return this.results;\n\n    } catch (error) {\n      console.error('‚ùå Analysis failed:', error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all .mdc files recursively\n   */\n  async getAllMdcFiles() {\n    const files = [];\n    \n    const scanDirectory = async (dir) => {\n      try {\n        const entries = await fs.readdir(dir, { withFileTypes: true });\n        \n        for (const entry of entries) {\n          const fullPath = path.join(dir, entry.name);\n          \n          if (entry.isDirectory()) {\n            await scanDirectory(fullPath);\n          } else if (entry.isFile() && entry.name.endsWith('.mdc')) {\n            files.push(fullPath);\n          }\n        }\n      } catch (error) {\n        console.warn(`‚ö†Ô∏è Could not scan directory ${dir}: ${error.message}`);\n      }\n    };\n\n    await scanDirectory(this.coreDir);\n    return files;\n  }\n\n  /**\n   * Analyze a single file for path issues\n   */\n  async analyzeFile(filePath) {\n    try {\n      const relativePath = path.relative(this.coreDir, filePath);\n      const filename = path.basename(filePath);\n      console.log(`üîç Analyzing: ${relativePath}`);\n\n      const content = await fs.readFile(filePath, 'utf8');\n      this.results.totalFiles++;\n\n      // 1. Check for obsolete .cursor patterns\n      await this.checkObsoletePaths(filePath, content, relativePath);\n      \n      // 2. Check for broken absolute paths\n      await this.checkBrokenAbsolute(filePath, content, relativePath);\n      \n      // 3. Check for self-references\n      await this.checkSelfReferences(filePath, content, relativePath, filename);\n      \n      // 4. Check for broken links\n      await this.checkBrokenLinks(filePath, content, relativePath);\n      \n      // 5. Check for missing referenced files\n      await this.checkMissingFiles(filePath, content, relativePath);\n      \n      // 6. Check for redundant path patterns\n      await this.checkRedundantPaths(filePath, content, relativePath);\n\n    } catch (error) {\n      console.error(`  ‚ùå Error analyzing ${filePath}: ${error.message}`);\n    }\n  }\n\n  /**\n   * Check for obsolete .cursor path patterns\n   */\n  async checkObsoletePaths(filePath, content, relativePath) {\n    for (const pattern of this.patterns.obsoleteCursor) {\n      const matches = content.match(pattern);\n      if (matches) {\n        for (const match of matches) {\n          this.results.obsoletePaths.push({\n            file: relativePath,\n            pattern: match,\n            type: 'obsolete_cursor',\n            severity: 'critical',\n            line: this.getLineNumber(content, match),\n            suggestion: 'Convert to relative path within _core structure'\n          });\n          this.results.summary.criticalIssues++;\n        }\n        console.log(`  üö® Found ${matches.length} obsolete .cursor paths`);\n      }\n    }\n  }\n\n  /**\n   * Check for broken absolute paths\n   */\n  async checkBrokenAbsolute(filePath, content, relativePath) {\n    for (const pattern of this.patterns.brokenAbsolute) {\n      const matches = content.match(pattern);\n      if (matches) {\n        for (const match of matches) {\n          this.results.corruptPaths.push({\n            file: relativePath,\n            pattern: match,\n            type: 'broken_absolute',\n            severity: 'high',\n            line: this.getLineNumber(content, match),\n            suggestion: 'Convert to proper relative path'\n          });\n          this.results.summary.criticalIssues++;\n        }\n        console.log(`  ‚ö†Ô∏è Found ${matches.length} broken absolute paths`);\n      }\n    }\n  }\n\n  /**\n   * Check for self-referential links\n   */\n  async checkSelfReferences(filePath, content, relativePath, filename) {\n    // Create patterns with actual filename\n    const selfRefPatterns = [\n      new RegExp(`\\\\[([^\\\\]]*?)\\\\]\\\\([^\\\\)]*?${this.escapeRegex(filename)}\\\\)`, 'g'),\n      new RegExp(`\\\\[${this.escapeRegex(filename)}\\\\]`, 'g')\n    ];\n\n    for (const pattern of selfRefPatterns) {\n      const matches = content.match(pattern);\n      if (matches) {\n        for (const match of matches) {\n          this.results.selfReferences.push({\n            file: relativePath,\n            pattern: match,\n            type: 'self_reference',\n            severity: 'medium',\n            line: this.getLineNumber(content, match),\n            suggestion: 'Remove self-referential link or convert to plain text'\n          });\n          this.results.summary.mediumIssues++;\n        }\n        console.log(`  üîÑ Found ${matches.length} self-references`);\n      }\n    }\n  }\n\n  /**\n   * Check for broken markdown links\n   */\n  async checkBrokenLinks(filePath, content, relativePath) {\n    for (const pattern of this.patterns.brokenLinks) {\n      const matches = content.match(pattern);\n      if (matches) {\n        for (const match of matches) {\n          this.results.brokenLinks.push({\n            file: relativePath,\n            pattern: match,\n            type: 'broken_link',\n            severity: 'medium',\n            line: this.getLineNumber(content, match),\n            suggestion: 'Fix or remove broken link'\n          });\n          this.results.summary.mediumIssues++;\n        }\n        console.log(`  üîó Found ${matches.length} broken links`);\n      }\n    }\n  }\n\n  /**\n   * Check for missing referenced files\n   */\n  async checkMissingFiles(filePath, content, relativePath) {\n    // Extract file references from links\n    const linkPattern = /\\[([^\\]]+)\\]\\(([^)]+\\.mdc)\\)/g;\n    let match;\n    \n    while ((match = linkPattern.exec(content)) !== null) {\n      const [fullMatch, linkText, referencedFile] = match;\n      \n      // Calculate absolute path to referenced file\n      const currentDir =",
  "metadata": {
    "content": "#!/usr/bin/env node\n\n/**\n * üîç Core Path Analyzer\n * \n * Comprehensive analyzer to detect corrupt, obsolete, and broken path patterns\n * in .cursor/rules/agents/_store/projects/_core content after migration\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\n\nclass CorePathAnalyzer {\n  constructor() {\n    this.coreDir = '.cursor/rules/agents/_store/projects/_core';\n    this.rulesDir = path.join(this.coreDir, 'rules');\n    this.results = {\n      totalFiles: 0,\n      corruptPaths: [],\n      obsoletePaths: [],\n      brokenLinks: [],\n      selfReferences: [],\n      missingFiles: [],\n      summary: {\n        totalIssues: 0,\n        criticalIssues: 0,\n        mediumIssues: 0,\n        lowIssues: 0\n      }\n    };\n    \n    // Pattern definitions for detection\n    this.patterns = {\n      // Obsolete .cursor patterns that should have been migrated\n      obsoleteCursor: [\n        /\\.cursor\\/rules\\/[^\\s\\)\\]\\,\\;]+/g,\n        /\\[([^\\]]+)\\]\\(\\.cursor\\/rules\\/([^)]+)\\)/g,\n        /`\\.cursor\\/rules\\/([^`]+)`/g\n      ],\n      \n      // Broken absolute paths\n      brokenAbsolute: [\n        /.cursor/rules/agents\\/_store\\/projects\\/_core\\/rules\\/[^\\s\\)\\]\\,\\;]+/g,\n        /\\[([^\\]]+)\\]\\(.cursor/rules/agents\\/_store\\/projects\\/_core\\/rules\\/([^)]+)\\)/g\n      ],\n      \n      // Self-referential patterns\n      selfReference: [\n        /\\[([^\\]]*?)\\]\\([^)]*?{filename}\\)/g,\n        /\\[{filename}\\]/g,\n        /\\[[^\\]]*\\]\\(\\s*\\)/g\n      ],\n      \n      // Broken markdown link formats\n      brokenLinks: [\n        /\\[([^\\]]+)\\]\\(\\s*\\)/g,\n        /\\]\\([0-9]+\\)/g,\n        /\\[[0-9]+\\]/g,\n        /\\[filename\\.mdc\\]/g,\n        /\\[t\\.mdc\\]/g\n      ],\n      \n      // Redundant path patterns\n      redundantPaths: [\n        /\\/\\.\\//g,\n        /\\/\\/+/g,\n        /\\.\\.\\//g,\n        /([^\\/])\\/\\/+/g\n      ]\n    };\n  }\n\n  /**\n   * Run comprehensive analysis\n   */\n  async analyze() {\n    console.log('üîç CORE PATH ANALYZER');\n    console.log('‚îÅ'.repeat(60));\n    console.log(`üìÅ Analyzing: ${this.coreDir}`);\n    console.log('');\n\n    try {\n      // Get all .mdc files\n      const mdcFiles = await this.getAllMdcFiles();\n      console.log(`üìÑ Found ${mdcFiles.length} .mdc files to analyze`);\n      console.log('');\n\n      // Analyze each file\n      for (const filePath of mdcFiles) {\n        await this.analyzeFile(filePath);\n      }\n\n      // Generate comprehensive report\n      await this.generateReport();\n      \n      return this.results;\n\n    } catch (error) {\n      console.error('‚ùå Analysis failed:', error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all .mdc files recursively\n   */\n  async getAllMdcFiles() {\n    const files = [];\n    \n    const scanDirectory = async (dir) => {\n      try {\n        const entries = await fs.readdir(dir, { withFileTypes: true });\n        \n        for (const entry of entries) {\n          const fullPath = path.join(dir, entry.name);\n          \n          if (entry.isDirectory()) {\n            await scanDirectory(fullPath);\n          } else if (entry.isFile() && entry.name.endsWith('.mdc')) {\n            files.push(fullPath);\n          }\n        }\n      } catch (error) {\n        console.warn(`‚ö†Ô∏è Could not scan directory ${dir}: ${error.message}`);\n      }\n    };\n\n    await scanDirectory(this.coreDir);\n    return files;\n  }\n\n  /**\n   * Analyze a single file for path issues\n   */\n  async analyzeFile(filePath) {\n    try {\n      const relativePath = path.relative(this.coreDir, filePath);\n      const filename = path.basename(filePath);\n      console.log(`üîç Analyzing: ${relativePath}`);\n\n      const content = await fs.readFile(filePath, 'utf8');\n      this.results.totalFiles++;\n\n      // 1. Check for obsolete .cursor patterns\n      await this.checkObsoletePaths(filePath, content, relativePath);\n      \n      // 2. Check for broken absolute paths\n      await this.checkBrokenAbsolute(filePath, content, relativePath);\n      \n      // 3. Check for self-references\n      await this.checkSelfReferences(filePath, content, relativePath, filename);\n      \n      // 4. Check for broken links\n      await this.checkBrokenLinks(filePath, content, relativePath);\n      \n      // 5. Check for missing referenced files\n      await this.checkMissingFiles(filePath, content, relativePath);\n      \n      // 6. Check for redundant path patterns\n      await this.checkRedundantPaths(filePath, content, relativePath);\n\n    } catch (error) {\n      console.error(`  ‚ùå Error analyzing ${filePath}: ${error.message}`);\n    }\n  }\n\n  /**\n   * Check for obsolete .cursor path patterns\n   */\n  async checkObsoletePaths(filePath, content, relativePath) {\n    for (const pattern of this.patterns.obsoleteCursor) {\n      const matches = content.match(pattern);\n      if (matches) {\n        for (const match of matches) {\n          this.results.obsoletePaths.push({\n            file: relativePath,\n            pattern: match,\n            type: 'obsolete_cursor',\n            severity: 'critical',\n            line: this.getLineNumber(content, match),\n            suggestion: 'Convert to relative path within _core structure'\n          });\n          this.results.summary.criticalIssues++;\n        }\n        console.log(`  üö® Found ${matches.length} obsolete .cursor paths`);\n      }\n    }\n  }\n\n  /**\n   * Check for broken absolute paths\n   */\n  async checkBrokenAbsolute(filePath, content, relativePath) {\n    for (const pattern of this.patterns.brokenAbsolute) {\n      const matches = content.match(pattern);\n      if (matches) {\n        for (const match of matches) {\n          this.results.corruptPaths.push({\n            file: relativePath,\n            pattern: match,\n            type: 'broken_absolute',\n            severity: 'high',\n            line: this.getLineNumber(content, match),\n            suggestion: 'Convert to proper relative path'\n          });\n          this.results.summary.criticalIssues++;\n        }\n        console.log(`  ‚ö†Ô∏è Found ${matches.length} broken absolute paths`);\n      }\n    }\n  }\n\n  /**\n   * Check for self-referential links\n   */\n  async checkSelfReferences(filePath, content, relativePath, filename) {\n    // Create patterns with actual filename\n    const selfRefPatterns = [\n      new RegExp(`\\\\[([^\\\\]]*?)\\\\]\\\\([^\\\\)]*?${this.escapeRegex(filename)}\\\\)`, 'g'),\n      new RegExp(`\\\\[${this.escapeRegex(filename)}\\\\]`, 'g')\n    ];\n\n    for (const pattern of selfRefPatterns) {\n      const matches = content.match(pattern);\n      if (matches) {\n        for (const match of matches) {\n          this.results.selfReferences.push({\n            file: relativePath,\n            pattern: match,\n            type: 'self_reference',\n            severity: 'medium',\n            line: this.getLineNumber(content, match),\n            suggestion: 'Remove self-referential link or convert to plain text'\n          });\n          this.results.summary.mediumIssues++;\n        }\n        console.log(`  üîÑ Found ${matches.length} self-references`);\n      }\n    }\n  }\n\n  /**\n   * Check for broken markdown links\n   */\n  async checkBrokenLinks(filePath, content, relativePath) {\n    for (const pattern of this.patterns.brokenLinks) {\n      const matches = content.match(pattern);\n      if (matches) {\n        for (const match of matches) {\n          this.results.brokenLinks.push({\n            file: relativePath,\n            pattern: match,\n            type: 'broken_link',\n            severity: 'medium',\n            line: this.getLineNumber(content, match),\n            suggestion: 'Fix or remove broken link'\n          });\n          this.results.summary.mediumIssues++;\n        }\n        console.log(`  üîó Found ${matches.length} broken links`);\n      }\n    }\n  }\n\n  /**\n   * Check for missing referenced files\n   */\n  async checkMissingFiles(filePath, content, relativePath) {\n    // Extract file references from links\n    const linkPattern = /\\[([^\\]]+)\\]\\(([^)]+\\.mdc)\\)/g;\n    let match;\n    \n    while ((match = linkPattern.exec(content)) !== null) {\n      const [fullMatch, linkText, referencedFile] = match;\n      \n      // Calculate absolute path to referenced file\n      const currentDir =",
    "description": "No description available",
    "filename": "core_path_analyzer.js",
    "functions": "CorePathAnalyzer",
    "keyFeatures": "Object-Oriented, Async/Await, File System, Path Manipulation, Process Management, Logging, JSON Processing, Regular Expressions",
    "originalPath": ".cursor/rules/agents/_store/projects/core_path_analyzer.js",
    "preservedAt": "2025-05-25T01:35:35.665Z",
    "size": 13816,
    "timestamp": "2025-05-25T01:38:00.055Z",
    "type": "preserved-code"
  },
  "embedding": []
}