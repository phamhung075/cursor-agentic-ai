{
  "id": "preserved-integrate_.cursor/rules/agents_architecture.js-1748137081140",
  "type": "preserved-code",
  "content": "#!/usr/bin/env node\n\n/**\n * ðŸ”„ .cursor/rules/agents Architecture Integration Script\n * \n * This script integrates the migrated .cursor content with the .cursor/rules/agents architecture\n * by updating all references, configurations, and ensuring proper file structure.\n */\n\nconst fs = require('fs');\nconst path = require('path');\n\nclass .cursor/rules/agentsArchitectureIntegrator {\n  constructor() {\n    this.timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    this.logFile = `.cursor/rules/agents/_store/logs/integration-${this.timestamp}.log`;\n    this.results = {\n      filesUpdated: 0,\n      pathsFixed: 0,\n      integrationSteps: 0,\n      errors: []\n    };\n    \n    // Ensure logs directory exists\n    if (!fs.existsSync('.cursor/rules/agents/_store/logs')) {\n      fs.mkdirSync('.cursor/rules/agents/_store/logs', { recursive: true });\n    }\n  }\n\n  log(message) {\n    const timestamp = new Date().toISOString();\n    const logMessage = `[${timestamp}] ${message}`;\n    console.log(logMessage);\n    fs.appendFileSync(this.logFile, logMessage + '\\n');\n  }\n\n  async integrate() {\n    try {\n      this.log('ðŸš€ Starting .cursor/rules/agents Architecture Integration...');\n      \n      // Step 1: Update Agent AI configuration\n      await this.updateAgentConfiguration();\n      \n      // Step 2: Update file manager to recognize new structure\n      await this.updateFileManager();\n      \n      // Step 3: Update project memory to reference new paths\n      await this.updateProjectMemory();\n      \n      // Step 4: Fix all .cursor references in the migrated content\n      await this.fixCursorReferences();\n      \n      // Step 5: Update Agent AI core files to integrate new structure\n      await this.updateAgentAICore();\n      \n      // Step 6: Create integration manifest\n      await this.createIntegrationManifest();\n      \n      this.log('âœ… .cursor/rules/agents Architecture Integration completed!');\n      return this.results;\n      \n    } catch (error) {\n      this.log(`âŒ Integration failed: ${error.message}`);\n      this.results.errors.push(error.message);\n      throw error;\n    }\n  }\n\n  async updateAgentConfiguration() {\n    this.log('ðŸ“ Step 1: Updating Agent AI configuration...');\n    \n    const configPath = '.cursor/rules/agents/self-improvement/config/default.json';\n    if (fs.existsSync(configPath)) {\n      const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));\n      \n      // Add core framework path to configuration\n      config.coreFramework = {\n        path: '.cursor/rules/agents/_store/projects/_core',\n        rulesPath: '.cursor/rules/agents/_store/projects/_core/rules',\n        workflowPath: '.cursor/rules/agents/_store/projects/_core/rules/01__AI-RUN',\n        templatesPath: '.cursor/rules/agents/_store/projects/_core/rules/02__AI-DOCS',\n        specsPath: '.cursor/rules/agents/_store/projects/_core/rules/03__SPECS'\n      };\n      \n      fs.writeFileSync(configPath, JSON.stringify(config, null, 2));\n      this.log('âœ… Updated Agent AI configuration with core framework paths');\n      this.results.integrationSteps++;\n    }\n  }\n\n  async updateFileManager() {\n    this.log('ðŸ“ Step 2: Updating File Manager integration...');\n    \n    const fileManagerPath = '.cursor/rules/agents/self-improvement/core/fileManager.js';\n    if (fs.existsSync(fileManagerPath)) {\n      let content = fs.readFileSync(fileManagerPath, 'utf8');\n      \n      // Add core framework access methods\n      const coreFrameworkMethods = `\n  /**\n   * Get core framework path\n   */\n  getCoreFrameworkPath() {\n    return path.resolve('.cursor/rules/agents/_store/projects/_core');\n  }\n\n  /**\n   * Access core workflow files\n   */\n  getCoreWorkflowFiles() {\n    const workflowPath = path.join(this.getCoreFrameworkPath(), 'rules/01__AI-RUN');\n    return this.listFiles(workflowPath, '.mdc');\n  }\n\n  /**\n   * Access core templates\n   */\n  getCoreTemplates() {\n    const templatesPath = path.join(this.getCoreFrameworkPath(), 'rules/02__AI-DOCS');\n    return this.listFiles(templatesPath, '.mdc');\n  }\n\n  /**\n   * Access core specifications\n   */\n  getCoreSpecs() {\n    const specsPath = path.join(this.getCoreFrameworkPath(), 'rules/03__SPECS');\n    return this.listFiles(specsPath, '.mdc');\n  }\n`;\n      \n      // Insert before the last closing brace\n      const lastBraceIndex = content.lastIndexOf('}');\n      content = content.slice(0, lastBraceIndex) + coreFrameworkMethods + '\\n}';\n      \n      fs.writeFileSync(fileManagerPath, content);\n      this.log('âœ… Updated File Manager with core framework integration');\n      this.results.integrationSteps++;\n    }\n  }\n\n  async updateProjectMemory() {\n    this.log('ðŸ§  Step 3: Updating Project Memory integration...');\n    \n    const memoryManagerPath = '.cursor/rules/agents/self-improvement/core/memory.js';\n    if (fs.existsSync(memoryManagerPath)) {\n      let content = fs.readFileSync(memoryManagerPath, 'utf8');\n      \n      // Add core framework memory integration\n      const memoryIntegration = `\n  /**\n   * Store core framework learning\n   */\n  async storeCoreFrameworkLearning(pattern, context = {}) {\n    const metadata = {\n      type: 'core_framework',\n      source: '.cursor/rules/agents/_store/projects/_core',\n      ...context,\n      timestamp: Date.now()\n    };\n    \n    return await this.storeAgentMemory('core_learning', JSON.stringify(pattern), metadata);\n  }\n\n  /**\n   * Retrieve core framework patterns\n   */\n  async getCoreFrameworkPatterns(query) {\n    const memories = await this.searchAgentMemory(query, {\n      filter: { type: 'core_framework' },\n      limit: 10\n    });\n    \n    return memories.map(memory => JSON.parse(memory.content));\n  }\n`;\n      \n      // Insert before the last closing brace\n      const lastBraceIndex = content.lastIndexOf('}');\n      content = content.slice(0, lastBraceIndex) + memoryIntegration + '\\n}';\n      \n      fs.writeFileSync(memoryManagerPath, content);\n      this.log('âœ… Updated Memory Manager with core framework integration');\n      this.results.integrationSteps++;\n    }\n  }\n\n  async fixCursorReferences() {\n    this.log('ðŸ”§ Step 4: Fixing .cursor references in migrated content...');\n    \n    const coreDir = '.cursor/rules/agents/_store/projects/_core';\n    const files = this.findAllMdcFiles(coreDir);\n    \n    for (const filePath of files) {\n      const originalContent = fs.readFileSync(filePath, 'utf8');\n      let content = originalContent;\n      \n      // Replace .cursor/rules/ with relative paths within the _core structure\n      content = this.fixPathReferences(content, filePath);\n      \n      if (content !== originalContent) {\n        fs.writeFileSync(filePath, content);\n        this.results.filesUpdated++;\n        this.log(`âœ… Fixed references in ${filePath}`);\n      }\n    }\n    \n    this.log(`âœ… Fixed references in ${this.results.filesUpdated} files`);\n    this.results.integrationSteps++;\n  }\n\n  fixPathReferences(content, currentFilePath) {\n    const currentDir = path.dirname(currentFilePath);\n    const coreRulesPath = '.cursor/rules/agents/_store/projects/_core/rules';\n    \n    // Calculate relative position within _core structure\n    const relativeToCore = path.relative(coreRulesPath, currentDir);\n    \n    // Replace .cursor/rules/ references with proper relative paths\n    content = content.replace(/\\.cursor\\/rules\\/([^\\s\\)\\]\\,\\;]+)/g, (match, targetPath) => {\n      if (relativeToCore === '') {\n        // We're in the rules directory\n        return targetPath;\n      } else if (relativeToCore.startsWith('..')) {\n        // We're outside rules directory\n        return path.join('rules', targetPath).replace(/\\\\/g, '/');\n      } else {\n        // We're in a subdirectory of rules\n        const depth = relativeToCore.split(path.sep).length;\n        const backtrack = '../'.repeat(depth);\n        return (backtrack + targetPath).replace(/\\\\/g, '/');\n      }\n    });\n    \n    // Fix markdown links\n    content = content.replace(/\\[([^\\]]+)\\]\\(\\.cursor\\/rules\\/([^)]+)\\)/g, (match, text, targetPath) => {\n      const relativePath = this.calculateRelativePath(currentDir, targetPath);\n      return `[${text}](${relativePath})`;\n    });\n    \n    this.results.pathsFixed++;\n    return content;\n  }\n\n  calculateRelativePath(currentDir, targetPath) {\n    const coreRulesPath = '.cursor/rules/agents/_store/projects/_core/rules';\n  ",
  "metadata": {
    "content": "#!/usr/bin/env node\n\n/**\n * ðŸ”„ .cursor/rules/agents Architecture Integration Script\n * \n * This script integrates the migrated .cursor content with the .cursor/rules/agents architecture\n * by updating all references, configurations, and ensuring proper file structure.\n */\n\nconst fs = require('fs');\nconst path = require('path');\n\nclass .cursor/rules/agentsArchitectureIntegrator {\n  constructor() {\n    this.timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    this.logFile = `.cursor/rules/agents/_store/logs/integration-${this.timestamp}.log`;\n    this.results = {\n      filesUpdated: 0,\n      pathsFixed: 0,\n      integrationSteps: 0,\n      errors: []\n    };\n    \n    // Ensure logs directory exists\n    if (!fs.existsSync('.cursor/rules/agents/_store/logs')) {\n      fs.mkdirSync('.cursor/rules/agents/_store/logs', { recursive: true });\n    }\n  }\n\n  log(message) {\n    const timestamp = new Date().toISOString();\n    const logMessage = `[${timestamp}] ${message}`;\n    console.log(logMessage);\n    fs.appendFileSync(this.logFile, logMessage + '\\n');\n  }\n\n  async integrate() {\n    try {\n      this.log('ðŸš€ Starting .cursor/rules/agents Architecture Integration...');\n      \n      // Step 1: Update Agent AI configuration\n      await this.updateAgentConfiguration();\n      \n      // Step 2: Update file manager to recognize new structure\n      await this.updateFileManager();\n      \n      // Step 3: Update project memory to reference new paths\n      await this.updateProjectMemory();\n      \n      // Step 4: Fix all .cursor references in the migrated content\n      await this.fixCursorReferences();\n      \n      // Step 5: Update Agent AI core files to integrate new structure\n      await this.updateAgentAICore();\n      \n      // Step 6: Create integration manifest\n      await this.createIntegrationManifest();\n      \n      this.log('âœ… .cursor/rules/agents Architecture Integration completed!');\n      return this.results;\n      \n    } catch (error) {\n      this.log(`âŒ Integration failed: ${error.message}`);\n      this.results.errors.push(error.message);\n      throw error;\n    }\n  }\n\n  async updateAgentConfiguration() {\n    this.log('ðŸ“ Step 1: Updating Agent AI configuration...');\n    \n    const configPath = '.cursor/rules/agents/self-improvement/config/default.json';\n    if (fs.existsSync(configPath)) {\n      const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));\n      \n      // Add core framework path to configuration\n      config.coreFramework = {\n        path: '.cursor/rules/agents/_store/projects/_core',\n        rulesPath: '.cursor/rules/agents/_store/projects/_core/rules',\n        workflowPath: '.cursor/rules/agents/_store/projects/_core/rules/01__AI-RUN',\n        templatesPath: '.cursor/rules/agents/_store/projects/_core/rules/02__AI-DOCS',\n        specsPath: '.cursor/rules/agents/_store/projects/_core/rules/03__SPECS'\n      };\n      \n      fs.writeFileSync(configPath, JSON.stringify(config, null, 2));\n      this.log('âœ… Updated Agent AI configuration with core framework paths');\n      this.results.integrationSteps++;\n    }\n  }\n\n  async updateFileManager() {\n    this.log('ðŸ“ Step 2: Updating File Manager integration...');\n    \n    const fileManagerPath = '.cursor/rules/agents/self-improvement/core/fileManager.js';\n    if (fs.existsSync(fileManagerPath)) {\n      let content = fs.readFileSync(fileManagerPath, 'utf8');\n      \n      // Add core framework access methods\n      const coreFrameworkMethods = `\n  /**\n   * Get core framework path\n   */\n  getCoreFrameworkPath() {\n    return path.resolve('.cursor/rules/agents/_store/projects/_core');\n  }\n\n  /**\n   * Access core workflow files\n   */\n  getCoreWorkflowFiles() {\n    const workflowPath = path.join(this.getCoreFrameworkPath(), 'rules/01__AI-RUN');\n    return this.listFiles(workflowPath, '.mdc');\n  }\n\n  /**\n   * Access core templates\n   */\n  getCoreTemplates() {\n    const templatesPath = path.join(this.getCoreFrameworkPath(), 'rules/02__AI-DOCS');\n    return this.listFiles(templatesPath, '.mdc');\n  }\n\n  /**\n   * Access core specifications\n   */\n  getCoreSpecs() {\n    const specsPath = path.join(this.getCoreFrameworkPath(), 'rules/03__SPECS');\n    return this.listFiles(specsPath, '.mdc');\n  }\n`;\n      \n      // Insert before the last closing brace\n      const lastBraceIndex = content.lastIndexOf('}');\n      content = content.slice(0, lastBraceIndex) + coreFrameworkMethods + '\\n}';\n      \n      fs.writeFileSync(fileManagerPath, content);\n      this.log('âœ… Updated File Manager with core framework integration');\n      this.results.integrationSteps++;\n    }\n  }\n\n  async updateProjectMemory() {\n    this.log('ðŸ§  Step 3: Updating Project Memory integration...');\n    \n    const memoryManagerPath = '.cursor/rules/agents/self-improvement/core/memory.js';\n    if (fs.existsSync(memoryManagerPath)) {\n      let content = fs.readFileSync(memoryManagerPath, 'utf8');\n      \n      // Add core framework memory integration\n      const memoryIntegration = `\n  /**\n   * Store core framework learning\n   */\n  async storeCoreFrameworkLearning(pattern, context = {}) {\n    const metadata = {\n      type: 'core_framework',\n      source: '.cursor/rules/agents/_store/projects/_core',\n      ...context,\n      timestamp: Date.now()\n    };\n    \n    return await this.storeAgentMemory('core_learning', JSON.stringify(pattern), metadata);\n  }\n\n  /**\n   * Retrieve core framework patterns\n   */\n  async getCoreFrameworkPatterns(query) {\n    const memories = await this.searchAgentMemory(query, {\n      filter: { type: 'core_framework' },\n      limit: 10\n    });\n    \n    return memories.map(memory => JSON.parse(memory.content));\n  }\n`;\n      \n      // Insert before the last closing brace\n      const lastBraceIndex = content.lastIndexOf('}');\n      content = content.slice(0, lastBraceIndex) + memoryIntegration + '\\n}';\n      \n      fs.writeFileSync(memoryManagerPath, content);\n      this.log('âœ… Updated Memory Manager with core framework integration');\n      this.results.integrationSteps++;\n    }\n  }\n\n  async fixCursorReferences() {\n    this.log('ðŸ”§ Step 4: Fixing .cursor references in migrated content...');\n    \n    const coreDir = '.cursor/rules/agents/_store/projects/_core';\n    const files = this.findAllMdcFiles(coreDir);\n    \n    for (const filePath of files) {\n      const originalContent = fs.readFileSync(filePath, 'utf8');\n      let content = originalContent;\n      \n      // Replace .cursor/rules/ with relative paths within the _core structure\n      content = this.fixPathReferences(content, filePath);\n      \n      if (content !== originalContent) {\n        fs.writeFileSync(filePath, content);\n        this.results.filesUpdated++;\n        this.log(`âœ… Fixed references in ${filePath}`);\n      }\n    }\n    \n    this.log(`âœ… Fixed references in ${this.results.filesUpdated} files`);\n    this.results.integrationSteps++;\n  }\n\n  fixPathReferences(content, currentFilePath) {\n    const currentDir = path.dirname(currentFilePath);\n    const coreRulesPath = '.cursor/rules/agents/_store/projects/_core/rules';\n    \n    // Calculate relative position within _core structure\n    const relativeToCore = path.relative(coreRulesPath, currentDir);\n    \n    // Replace .cursor/rules/ references with proper relative paths\n    content = content.replace(/\\.cursor\\/rules\\/([^\\s\\)\\]\\,\\;]+)/g, (match, targetPath) => {\n      if (relativeToCore === '') {\n        // We're in the rules directory\n        return targetPath;\n      } else if (relativeToCore.startsWith('..')) {\n        // We're outside rules directory\n        return path.join('rules', targetPath).replace(/\\\\/g, '/');\n      } else {\n        // We're in a subdirectory of rules\n        const depth = relativeToCore.split(path.sep).length;\n        const backtrack = '../'.repeat(depth);\n        return (backtrack + targetPath).replace(/\\\\/g, '/');\n      }\n    });\n    \n    // Fix markdown links\n    content = content.replace(/\\[([^\\]]+)\\]\\(\\.cursor\\/rules\\/([^)]+)\\)/g, (match, text, targetPath) => {\n      const relativePath = this.calculateRelativePath(currentDir, targetPath);\n      return `[${text}](${relativePath})`;\n    });\n    \n    this.results.pathsFixed++;\n    return content;\n  }\n\n  calculateRelativePath(currentDir, targetPath) {\n    const coreRulesPath = '.cursor/rules/agents/_store/projects/_core/rules';\n  ",
    "description": "No description available",
    "filename": "integrate_.cursor/rules/agents_architecture.js",
    "functions": ".cursor/rules/agentsArchitectureIntegrator",
    "keyFeatures": "Object-Oriented, Async/Await, File System, Path Manipulation, Logging, JSON Processing",
    "originalPath": ".cursor/rules/agents/_store/projects/integrate_.cursor/rules/agents_architecture.js",
    "preservedAt": "2025-05-25T01:35:35.672Z",
    "size": 12399,
    "timestamp": "2025-05-25T01:38:01.140Z",
    "type": "preserved-code"
  },
  "embedding": []
}