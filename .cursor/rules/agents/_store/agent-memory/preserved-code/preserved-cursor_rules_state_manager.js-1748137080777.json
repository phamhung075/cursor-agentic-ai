{
  "id": "preserved-cursor_rules_state_manager.js-1748137080777",
  "type": "preserved-code",
  "content": "#!/usr/bin/env node\n\n/**\n * üóÇÔ∏è Cursor Rules State Manager\n * \n * Comprehensive state management system for .cursor/rules files\n * Handles content updates, path fixes, and synchronization with agent capabilities\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\nconst crypto = require('crypto');\n\nclass CursorRulesStateManager {\n  constructor() {\n    this.baseDir = path.join(process.cwd(), '.cursor/rules');\n    this.stateFile = path.join(__dirname, '../project-memory/cursor_rules_state.json');\n    this.projectMemoryDir = path.join(__dirname, '../project-memory');\n    this.projectsDir = path.join(__dirname, '../projects');\n    \n    this.state = {\n      lastUpdated: null,\n      files: {},\n      directories: {},\n      metadata: {\n        totalFiles: 0,\n        totalDirectories: 0,\n        lastScan: null,\n        version: '1.0.0'\n      }\n    };\n  }\n\n  /**\n   * Initialize the state manager\n   */\n  async initialize() {\n    console.log('üóÇÔ∏è Initializing Cursor Rules State Manager...');\n    \n    // Ensure directories exist\n    await fs.mkdir(this.projectMemoryDir, { recursive: true });\n    await fs.mkdir(this.projectsDir, { recursive: true });\n    \n    // Load existing state if available\n    await this.loadState();\n    \n    // Scan current files\n    await this.scanAllFiles();\n    \n    console.log('‚úÖ State Manager initialized');\n    console.log(`üìä Tracking ${this.state.metadata.totalFiles} files in ${this.state.metadata.totalDirectories} directories`);\n  }\n\n  /**\n   * Load existing state from file\n   */\n  async loadState() {\n    try {\n      const stateData = await fs.readFile(this.stateFile, 'utf8');\n      const loadedState = JSON.parse(stateData);\n      this.state = { ...this.state, ...loadedState };\n      console.log('üíæ Loaded existing state');\n    } catch (error) {\n      console.log('üÜï Creating new state file');\n    }\n  }\n\n  /**\n   * Save current state to file\n   */\n  async saveState() {\n    this.state.lastUpdated = new Date().toISOString();\n    await fs.writeFile(this.stateFile, JSON.stringify(this.state, null, 2));\n    console.log('üíæ State saved');\n  }\n\n  /**\n   * Scan all files in .cursor/rules directory\n   */\n  async scanAllFiles() {\n    console.log('üîç Scanning .cursor/rules directory...');\n    \n    this.state.metadata.lastScan = new Date().toISOString();\n    await this.scanDirectory(this.baseDir, '');\n    \n    this.state.metadata.totalFiles = Object.keys(this.state.files).length;\n    this.state.metadata.totalDirectories = Object.keys(this.state.directories).length;\n    \n    await this.saveState();\n  }\n\n  /**\n   * Recursively scan a directory\n   */\n  async scanDirectory(fullPath, relativePath) {\n    try {\n      const entries = await fs.readdir(fullPath, { withFileTypes: true });\n      \n      // Track directory\n      if (relativePath) {\n        this.state.directories[relativePath] = {\n          path: relativePath,\n          fullPath: fullPath,\n          lastScanned: new Date().toISOString(),\n          itemCount: entries.length\n        };\n      }\n      \n      for (const entry of entries) {\n        const entryPath = path.join(fullPath, entry.name);\n        const relativeEntryPath = relativePath ? path.join(relativePath, entry.name) : entry.name;\n        \n        if (entry.isDirectory()) {\n          await this.scanDirectory(entryPath, relativeEntryPath);\n        } else if (entry.isFile()) {\n          await this.analyzeFile(entryPath, relativeEntryPath);\n        }\n      }\n    } catch (error) {\n      console.warn(`‚ö†Ô∏è Error scanning directory ${fullPath}:`, error.message);\n    }\n  }\n\n  /**\n   * Analyze a single file and create state entry\n   */\n  async analyzeFile(fullPath, relativePath) {\n    try {\n      const stats = await fs.stat(fullPath);\n      const content = await fs.readFile(fullPath, 'utf8');\n      const contentHash = crypto.createHash('md5').update(content).digest('hex');\n      \n      // Determine file type and category\n      const fileInfo = this.analyzeFileContent(content, relativePath);\n      \n      this.state.files[relativePath] = {\n        // Basic file info\n        path: relativePath,\n        fullPath: fullPath,\n        filename: path.basename(relativePath),\n        extension: path.extname(relativePath),\n        directory: path.dirname(relativePath),\n        \n        // Content tracking\n        contentHash: contentHash,\n        size: stats.size,\n        lastModified: stats.mtime.toISOString(),\n        lastAnalyzed: new Date().toISOString(),\n        \n        // Content analysis\n        category: fileInfo.category,\n        type: fileInfo.type,\n        purpose: fileInfo.purpose,\n        dependencies: fileInfo.dependencies,\n        references: fileInfo.references,\n        \n        // Status tracking\n        status: 'analyzed',\n        needsUpdate: false,\n        issues: [],\n        \n        // Agent integration\n        agentCompatible: fileInfo.agentCompatible,\n        modernizationNeeded: fileInfo.modernizationNeeded,\n        \n        // Metadata\n        lineCount: content.split('\\n').length,\n        wordCount: content.split(/\\s+/).length,\n        hasCodeBlocks: content.includes('```'),\n        hasTables: content.includes('|'),\n        hasLinks: content.includes('[') && content.includes(']')\n      };\n      \n      // Check for issues\n      await this.detectIssues(relativePath, content);\n      \n    } catch (error) {\n      console.warn(`‚ö†Ô∏è Error analyzing file ${fullPath}:`, error.message);\n    }\n  }\n\n  /**\n   * Analyze file content to determine type and characteristics\n   */\n  analyzeFileContent(content, relativePath) {\n    const filename = path.basename(relativePath);\n    const directory = path.dirname(relativePath);\n    \n    let category = 'unknown';\n    let type = 'documentation';\n    let purpose = 'general';\n    let agentCompatible = true;\n    let modernizationNeeded = false;\n    \n    // Determine category by directory\n    if (directory.includes('01__AI-RUN')) {\n      category = 'workflow';\n      type = 'agent-workflow';\n    } else if (directory.includes('02__AI-DOCS')) {\n      category = 'documentation';\n      type = 'agent-docs';\n    } else if (directory.includes('03__SPECS')) {\n      category = 'specifications';\n      type = 'technical-specs';\n    } else if (directory.includes('00__TOOLS')) {\n      category = 'tools';\n      type = 'utilities';\n    } else if (directory.includes('projet')) {\n      category = 'project';\n      type = 'project-data';\n    } else if (directory.includes('tasks')) {\n      category = 'tasks';\n      type = 'task-management';\n    }\n    \n    // Determine purpose by filename\n    if (filename.includes('Getting_Started')) {\n      purpose = 'onboarding';\n    } else if (filename.includes('AutoPilot')) {\n      purpose = 'automation';\n    } else if (filename.includes('PRD')) {\n      purpose = 'requirements';\n    } else if (filename.includes('Market_Research')) {\n      purpose = 'research';\n    } else if (filename.includes('Testing')) {\n      purpose = 'testing';\n    } else if (filename.includes('Deployment')) {\n      purpose = 'deployment';\n    }\n    \n    // Extract dependencies and references\n    const dependencies = this.extractDependencies(content);\n    const references = this.extractReferences(content);\n    \n    // Check for modernization needs\n    modernizationNeeded = this.needsModernization(content);\n    \n    return {\n      category,\n      type,\n      purpose,\n      dependencies,\n      references,\n      agentCompatible,\n      modernizationNeeded\n    };\n  }\n\n  /**\n   * Extract file dependencies from content\n   */\n  extractDependencies(content) {\n    const dependencies = [];\n    \n    // Extract .mdc file references\n    const mdcRefs = content.match(/\\[([^\\]]+\\.mdc)\\]/g);\n    if (mdcRefs) {\n      dependencies.push(...mdcRefs.map(ref => ref.slice(1, -1)));\n    }\n    \n    // Extract path references\n    const pathRefs = content.match(/.cursor/rules/agents\\/_store\\/projects\\/_core\\/rules\\/[^)\\s]+/g);\n    if (pathRefs) {\n      dependencies.push(...pathRefs);\n    }\n    \n    return [...new Set(dependencies)];\n  }\n\n  /**",
  "metadata": {
    "content": "#!/usr/bin/env node\n\n/**\n * üóÇÔ∏è Cursor Rules State Manager\n * \n * Comprehensive state management system for .cursor/rules files\n * Handles content updates, path fixes, and synchronization with agent capabilities\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\nconst crypto = require('crypto');\n\nclass CursorRulesStateManager {\n  constructor() {\n    this.baseDir = path.join(process.cwd(), '.cursor/rules');\n    this.stateFile = path.join(__dirname, '../project-memory/cursor_rules_state.json');\n    this.projectMemoryDir = path.join(__dirname, '../project-memory');\n    this.projectsDir = path.join(__dirname, '../projects');\n    \n    this.state = {\n      lastUpdated: null,\n      files: {},\n      directories: {},\n      metadata: {\n        totalFiles: 0,\n        totalDirectories: 0,\n        lastScan: null,\n        version: '1.0.0'\n      }\n    };\n  }\n\n  /**\n   * Initialize the state manager\n   */\n  async initialize() {\n    console.log('üóÇÔ∏è Initializing Cursor Rules State Manager...');\n    \n    // Ensure directories exist\n    await fs.mkdir(this.projectMemoryDir, { recursive: true });\n    await fs.mkdir(this.projectsDir, { recursive: true });\n    \n    // Load existing state if available\n    await this.loadState();\n    \n    // Scan current files\n    await this.scanAllFiles();\n    \n    console.log('‚úÖ State Manager initialized');\n    console.log(`üìä Tracking ${this.state.metadata.totalFiles} files in ${this.state.metadata.totalDirectories} directories`);\n  }\n\n  /**\n   * Load existing state from file\n   */\n  async loadState() {\n    try {\n      const stateData = await fs.readFile(this.stateFile, 'utf8');\n      const loadedState = JSON.parse(stateData);\n      this.state = { ...this.state, ...loadedState };\n      console.log('üíæ Loaded existing state');\n    } catch (error) {\n      console.log('üÜï Creating new state file');\n    }\n  }\n\n  /**\n   * Save current state to file\n   */\n  async saveState() {\n    this.state.lastUpdated = new Date().toISOString();\n    await fs.writeFile(this.stateFile, JSON.stringify(this.state, null, 2));\n    console.log('üíæ State saved');\n  }\n\n  /**\n   * Scan all files in .cursor/rules directory\n   */\n  async scanAllFiles() {\n    console.log('üîç Scanning .cursor/rules directory...');\n    \n    this.state.metadata.lastScan = new Date().toISOString();\n    await this.scanDirectory(this.baseDir, '');\n    \n    this.state.metadata.totalFiles = Object.keys(this.state.files).length;\n    this.state.metadata.totalDirectories = Object.keys(this.state.directories).length;\n    \n    await this.saveState();\n  }\n\n  /**\n   * Recursively scan a directory\n   */\n  async scanDirectory(fullPath, relativePath) {\n    try {\n      const entries = await fs.readdir(fullPath, { withFileTypes: true });\n      \n      // Track directory\n      if (relativePath) {\n        this.state.directories[relativePath] = {\n          path: relativePath,\n          fullPath: fullPath,\n          lastScanned: new Date().toISOString(),\n          itemCount: entries.length\n        };\n      }\n      \n      for (const entry of entries) {\n        const entryPath = path.join(fullPath, entry.name);\n        const relativeEntryPath = relativePath ? path.join(relativePath, entry.name) : entry.name;\n        \n        if (entry.isDirectory()) {\n          await this.scanDirectory(entryPath, relativeEntryPath);\n        } else if (entry.isFile()) {\n          await this.analyzeFile(entryPath, relativeEntryPath);\n        }\n      }\n    } catch (error) {\n      console.warn(`‚ö†Ô∏è Error scanning directory ${fullPath}:`, error.message);\n    }\n  }\n\n  /**\n   * Analyze a single file and create state entry\n   */\n  async analyzeFile(fullPath, relativePath) {\n    try {\n      const stats = await fs.stat(fullPath);\n      const content = await fs.readFile(fullPath, 'utf8');\n      const contentHash = crypto.createHash('md5').update(content).digest('hex');\n      \n      // Determine file type and category\n      const fileInfo = this.analyzeFileContent(content, relativePath);\n      \n      this.state.files[relativePath] = {\n        // Basic file info\n        path: relativePath,\n        fullPath: fullPath,\n        filename: path.basename(relativePath),\n        extension: path.extname(relativePath),\n        directory: path.dirname(relativePath),\n        \n        // Content tracking\n        contentHash: contentHash,\n        size: stats.size,\n        lastModified: stats.mtime.toISOString(),\n        lastAnalyzed: new Date().toISOString(),\n        \n        // Content analysis\n        category: fileInfo.category,\n        type: fileInfo.type,\n        purpose: fileInfo.purpose,\n        dependencies: fileInfo.dependencies,\n        references: fileInfo.references,\n        \n        // Status tracking\n        status: 'analyzed',\n        needsUpdate: false,\n        issues: [],\n        \n        // Agent integration\n        agentCompatible: fileInfo.agentCompatible,\n        modernizationNeeded: fileInfo.modernizationNeeded,\n        \n        // Metadata\n        lineCount: content.split('\\n').length,\n        wordCount: content.split(/\\s+/).length,\n        hasCodeBlocks: content.includes('```'),\n        hasTables: content.includes('|'),\n        hasLinks: content.includes('[') && content.includes(']')\n      };\n      \n      // Check for issues\n      await this.detectIssues(relativePath, content);\n      \n    } catch (error) {\n      console.warn(`‚ö†Ô∏è Error analyzing file ${fullPath}:`, error.message);\n    }\n  }\n\n  /**\n   * Analyze file content to determine type and characteristics\n   */\n  analyzeFileContent(content, relativePath) {\n    const filename = path.basename(relativePath);\n    const directory = path.dirname(relativePath);\n    \n    let category = 'unknown';\n    let type = 'documentation';\n    let purpose = 'general';\n    let agentCompatible = true;\n    let modernizationNeeded = false;\n    \n    // Determine category by directory\n    if (directory.includes('01__AI-RUN')) {\n      category = 'workflow';\n      type = 'agent-workflow';\n    } else if (directory.includes('02__AI-DOCS')) {\n      category = 'documentation';\n      type = 'agent-docs';\n    } else if (directory.includes('03__SPECS')) {\n      category = 'specifications';\n      type = 'technical-specs';\n    } else if (directory.includes('00__TOOLS')) {\n      category = 'tools';\n      type = 'utilities';\n    } else if (directory.includes('projet')) {\n      category = 'project';\n      type = 'project-data';\n    } else if (directory.includes('tasks')) {\n      category = 'tasks';\n      type = 'task-management';\n    }\n    \n    // Determine purpose by filename\n    if (filename.includes('Getting_Started')) {\n      purpose = 'onboarding';\n    } else if (filename.includes('AutoPilot')) {\n      purpose = 'automation';\n    } else if (filename.includes('PRD')) {\n      purpose = 'requirements';\n    } else if (filename.includes('Market_Research')) {\n      purpose = 'research';\n    } else if (filename.includes('Testing')) {\n      purpose = 'testing';\n    } else if (filename.includes('Deployment')) {\n      purpose = 'deployment';\n    }\n    \n    // Extract dependencies and references\n    const dependencies = this.extractDependencies(content);\n    const references = this.extractReferences(content);\n    \n    // Check for modernization needs\n    modernizationNeeded = this.needsModernization(content);\n    \n    return {\n      category,\n      type,\n      purpose,\n      dependencies,\n      references,\n      agentCompatible,\n      modernizationNeeded\n    };\n  }\n\n  /**\n   * Extract file dependencies from content\n   */\n  extractDependencies(content) {\n    const dependencies = [];\n    \n    // Extract .mdc file references\n    const mdcRefs = content.match(/\\[([^\\]]+\\.mdc)\\]/g);\n    if (mdcRefs) {\n      dependencies.push(...mdcRefs.map(ref => ref.slice(1, -1)));\n    }\n    \n    // Extract path references\n    const pathRefs = content.match(/.cursor/rules/agents\\/_store\\/projects\\/_core\\/rules\\/[^)\\s]+/g);\n    if (pathRefs) {\n      dependencies.push(...pathRefs);\n    }\n    \n    return [...new Set(dependencies)];\n  }\n\n  /**",
    "description": "No description available",
    "filename": "cursor_rules_state_manager.js",
    "functions": "CursorRulesStateManager",
    "keyFeatures": "Object-Oriented, Async/Await, File System, Path Manipulation, Logging, JSON Processing",
    "originalPath": ".cursor/rules/agents/_store/projects/cursor_rules_state_manager.js",
    "preservedAt": "2025-05-25T01:35:35.670Z",
    "size": 15443,
    "timestamp": "2025-05-25T01:38:00.777Z",
    "type": "preserved-code"
  },
  "embedding": []
}