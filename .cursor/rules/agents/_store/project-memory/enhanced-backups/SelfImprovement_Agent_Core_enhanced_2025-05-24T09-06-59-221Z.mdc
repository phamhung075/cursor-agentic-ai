---
description: 
globs: 
alwaysApply: false
---
# ðŸ¤– Self-Improvement Agent Core Implementation

## Analysis Patterns & Detection Rules

### File Content Analysis Patterns

#### 1. **Obsolescence Detection**
```javascript
const obsolescencePatterns = {
  // Technology version patterns
  technologyVersions: {
    "React 18": "Consider upgrading to React 18+ for better performance",
    "Node.js 20": "Node.js 20+ is recommended for security updates",
    "TypeScript 5.0": "TypeScript 5.0+ offers significant improvements",
    "Next.js 14": "Next.js 14+ with App Router provides better developer experience"
  },
  
  // Deprecated API patterns
  deprecatedAPIs: {
    "componentWillMount": "Use useEffect hook instead",
    "findDOMNode": "Use refs for DOM access",
    "UNSAFE_": "Replace with modern lifecycle methods"
  },
  
  // Outdated practices
  outdatedPractices: {
    "class components without hooks": "Consider functional components with hooks",
    "inline styles": "Use CSS modules or styled-components",
    "fetch without error handling": "Add proper error handling and loading states"
  }
};
```

#### 2. **Logic Inconsistency Detection**
```javascript
const logicPatterns = {
  // Workflow inconsistencies
  workflowInconsistencies: [
    {
      pattern: "Missing error handling in user input validation",
      files: ["*_Generation.mdc", "*_Building.mdc"],
      severity: "high"
    },
    {
      pattern: "Inconsistent file naming conventions",
      files: ["*.mdc"],
      severity: "medium"
    },
    {
      pattern: "Missing user approval steps for critical changes",
      files: ["*AutoPilot*", "*Building*"],
      severity: "high"
    }
  ],
  
  // Cross-file dependency issues
  dependencyIssues: [
    {
      pattern: "References to non-existent files",
      check: "linkValidation",
      severity: "high"
    },
    {
      pattern: "Circular workflow dependencies",
      check: "circularDependencyDetection",
      severity: "medium"
    }
  ]
};
```

#### 3. **Best Practice Gap Detection**
```javascript
const bestPracticeGaps = {
  // Security patterns
  security: [
    "Missing input sanitization guidelines",
    "No mention of API key security",
    "Absent CORS configuration guidance",
    "Missing authentication flow documentation"
  ],
  
  // Performance patterns
  performance: [
    "No lazy loading recommendations",
    "Missing code splitting guidance",
    "Absent caching strategies",
    "No bundle size optimization"
  ],
  
  // Accessibility patterns
  accessibility: [
    "Missing ARIA label guidelines",
    "No keyboard navigation patterns",
    "Absent color contrast requirements",
    "Missing screen reader support"
  ],
  
  // User Experience patterns
  userExperience: [
    "No loading state patterns",
    "Missing error message standards",
    "Absent responsive design guidelines",
    "No offline capability considerations"
  ]
};
```

### 4. **Content Quality Analysis**
```javascript
const contentQualityChecks = {
  // Documentation completeness
  documentation: {
    requiredSections: [
      "Introduction",
      "Implementation Steps", 
      "Examples",
      "Error Handling",
      "Next Steps"
    ],
    qualityIndicators: [
      "Clear step-by-step instructions",
      "Code examples with explanations",
      "Error scenarios and solutions",
      "Links to related documentation"
    ]
  },
  
  // Clarity and consistency
  clarity: {
    checks: [
      "Consistent terminology usage",
      "Clear action words (must, should, can)",
      "Proper markdown formatting",
      "Logical information flow"
    ]
  }
};
```

## Improvement Generation Engine

### 1. **Content Enhancement Algorithms**
```javascript
class ContentEnhancer {
  analyzeContent(fileContent, filePath) {
    const improvements = ;
    
    // Check for missing sections
    const missingSections = this.detectMissingSections(fileContent);
    improvements.push(...missingSections);
    
    // Analyze code examples
    const codeImprovements = this.analyzeCodeExamples(fileContent);
    improvements.push(...codeImprovements);
    
    // Check for outdated references
    const outdatedContent = this.detectOutdatedContent(fileContent);
    improvements.push(...outdatedContent);
    
    return improvements;
  }
  
  detectMissingSections(content) {
    const improvements = ;
    const requiredSections = [
      'Error Handling',
      'Best Practices', 
      'Examples',
      'Troubleshooting'
    ];
    
    requiredSections.forEach(section => {
      if (!content.includes(`## ${section}`) && !content.includes(`### ${section}`)) {
        improvements.push({
          type: 'missing_section',
          section: section,
          priority: 'medium',
          description: `Missing ${section} section could improve user guidance`
        });
      }
    });
    
    return improvements;
  }
  
  analyzeCodeExamples(content) {
    const improvements = ;
    const codeBlocks = content.match(/```[\s\S]*?```/g) || ;
    
    codeBlocks.forEach((block, index) => {
      // Check for modern practices
      if (block.includes('var ') && block.includes('javascript')) {
        improvements.push({
          type: 'code_modernization',
          location: `Code block ${index + 1}`,
          priority: 'low',
          description: 'Consider using const/let instead of var',
          suggestion: block.replace(/var /g, 'const ')
        });
      }
      
      // Check for error handling
      if (block.includes('fetch(') && !block.includes('catch')) {
        improvements.push({
          type: 'missing_error_handling',
          location: `Code block ${index + 1}`,
          priority: 'high',
          description: 'Fetch requests should include error handling'
        });
      }
    });
    
    return improvements;
  }
}
```

### 2. **Logic Flow Optimizer**
```javascript
class LogicFlowOptimizer {
  analyzeWorkflow(fileContent, fileName) {
    const optimizations = ;
    
    // Check for redundant steps
    const redundancies = this.detectRedundantSteps(fileContent);
    optimizations.push(...redundancies);
    
    // Analyze decision points
    const decisionOptimizations = this.optimizeDecisionPoints(fileContent);
    optimizations.push(...decisionOptimizations);
    
    // Check for missing validation steps
    const validationGaps = this.detectValidationGaps(fileContent);
    optimizations.push(...validationGaps);
    
    return optimizations;
  }
  
  detectRedundantSteps(content) {
    const optimizations = ;
    
    // Look for repeated validation patterns
    const validationMatches = content.match(/validate|check|verify/gi) || ;
    if (validationMatches.length > 5) {
      optimizations.push({
        type: 'workflow_optimization',
        issue: 'excessive_validation',
        priority: 'medium',
        description: 'Multiple validation steps could be consolidated',
        suggestion: 'Consider creating a unified validation function'
      });
    }
    
    return optimizations;
  }
}
```

## User Communication System

### 1. **Improvement Notification Templates**
```markdown
# Improvement Notification Templates

## Template: Obsolete Technology Detection
---
## ðŸ”„ Technology Update Recommended

**File**: `{filePath}`
**Current**: {currentTechnology}
**Recommended**: {recommendedTechnology}
**Impact**: {impactDescription}
**Priority**: {priority}

### Why This Matters:
{explanation}

### Proposed Changes:
{proposedChanges}

**Would you like me to update this reference?**
-  Yes, update it
-  No, keep current
-  Show me more details first
---
```

```markdown
## Template: Logic Improvement
---
## ðŸ§  Logic Enhancement Opportunity

**File**: `{filePath}`
**Section**: {sectionName}
**Issue**: {issueDescription}
**Improvement Type**: {improvementType}

### Current Logic:
```
{currentLogic}
```

### Proposed Enhancement:
```
{proposedLogic}
```

### Benefits:
- {benefit1}
- {benefit2}
- {benefit3}

**Shall I implement this improvement?**
---
```

### 2. **Learning Feedback Collection**
```javascript
class FeedbackCollector {
  collectUserFeedback(improvement, userResponse) {
    const feedback = {
      improvementId: improvement.id,
      userResponse: userResponse, // 'approved', 'rejected', 'modified'
      timestamp: new Date.toISOString,
      context: {
        fileType: improvement.fileType,
        improvementType: improvement.type,
        priority: improvement.priority
      }
    };
    
    this.updateLearningModel(feedback);
    return feedback;
  }
  
  updateLearningModel(feedback) {
    // Update pattern recognition based on user preferences
    this.learningModel.updateWeights(feedback);
    
    // Adjust future suggestion confidence
    this.adjustConfidenceScores(feedback);
    
    // Build user preference profile
    this.buildUserProfile(feedback);
  }
}
```

## Implementation Workflow

### Phase 1: Analysis System Setup
```bash
# 1. Create monitoring system
npm install chokidar # File watching
npm install gray-matter # MDC file parsing
npm install marked # Markdown processing

# 2. Set up analysis pipeline
- File change detection
- Content parsing and analysis
- Pattern matching engine
- Issue prioritization system
```

### Phase 2: Learning System Implementation
```javascript
// Learning system components
class LearningSystem {
  constructor {
    this.knowledgeBase = new Map;
    this.userPreferences = new Map;
    this.improvementHistory = ;
  }
  
  learn(feedback) {
    // Update pattern weights based on user feedback
    this.updatePatternWeights(feedback);
    
    // Build contextual understanding
    this.buildContextualRules(feedback);
    
    // Improve future suggestions
    this.refineDetectionAlgorithms(feedback);
  }
}
```

### Phase 3: Safe Modification System
```javascript
class SafeModificationSystem {
  async implementImprovement(improvement, userApproval) {
    try {
      // 1. Create backup
      await this.createBackup(improvement.filePath);
      
      // 2. Apply changes
      const result = await this.applyChanges(improvement);
      
      // 3. Validate changes
      const validation = await this.validateChanges(result);
      
      // 4. Monitor impact
      this.monitorImpact(improvement, result);
      
      return { success: true, result };
    } catch (error) {
      // Rollback on failure
      await this.rollback(improvement.filePath);
      return { success: false, error };
    }
  }
}
```

## Next Implementation Steps

1. **Start with Analysis**: Begin implementing the content analysis patterns
2. **Build Detection Engine**: Create the pattern matching and logic validation systems
3. **Implement User Interface**: Build the communication and approval system
4. **Add Learning Loop**: Implement feedback collection and adaptation
5. **Deploy Monitoring**: Set up continuous file monitoring and analysis

This creates a robust foundation for your self-improving AI agent that can continuously enhance the framework while ensuring safety and user control.
