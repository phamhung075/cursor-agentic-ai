---
description: 
globs: 
alwaysApply: false
---
# 🔄 Cursor Workflow Automation Rules for MCP Task Management

**Automated workflow integration rules for seamless task management during development**

## 🚀 Development Workflow Rules
# 🔄 Workflow Automation Rules for Cursor IDE

**Advanced workflow automation sequences for development process integration**

> **📝 IMPORTANT FOR CURSOR AI**: When modifying this file, you MUST also update:
> - [CENTRALIZED_MCP_RULES.mdc](mdc:.cursor/rules/CENTRALIZED_MCP_RULES.mdc) - Update workflow summaries and links
> - [MCP_TASK_MANAGEMENT_RULES.mdc](mdc:.cursor/rules/MCP_TASK_MANAGEMENT_RULES.mdc) - Check rule dependencies
> - [CURSOR_MCP_CONFIG.mdc](mdc:.cursor/rules/CURSOR_MCP_CONFIG.mdc) - Update event handlers and triggers
> 
> **File Dependencies**: This file extends the core MCP rules with workflow-specific automation sequences.

# 🔄 Cursor Workflow Automation Rules for MCP Task Management

**Automated workflow integration rules for seamless task management during development**

## 🚀 Development Workflow Rules

### Workflow 1: New Feature Development
**Trigger**: Creating a new feature branch or starting feature work
**Automation Sequence**:

```typescript
// Step 1: Feature Branch Detection
if (branchName.includes('feature/') || branchName.includes('feat/')) {
  
  // Step 2: Create Main Feature Task
  const featureTask = await mcp.call('create_task', {
    title: `Feature: ${extractFeatureName(branchName)}`,
    description: `Implementation of ${featureName} feature`,
    priority: "high",
    projectId: getCurrentProjectId(),
    tags: ["feature", "development"],
    estimatedHours: 16 // Default for features
  });
  
  // Step 3: AI-Powered Task Decomposition
  const decomposition = await mcp.call('decompose_task', {
    taskId: featureTask.id,
    maxDepth: 3,
    analysisType: "comprehensive",
    includeEstimates: true
  });
  
  // Step 4: Set Up Task Hierarchy
  for (const subtask of decomposition.subtasks) {
    await mcp.call('update_task', {
      taskId: subtask.id,
      parentId: featureTask.id,
      priority: calculateSubtaskPriority(subtask)
    });
  }
}
```

### Workflow 2: Bug Fix Process
**Trigger**: Working on bug fixes or hotfixes
**Automation Sequence**:

```typescript
// Bug Detection Patterns
const bugPatterns = [
  /bug[\/\-_]/, /fix[\/\-_]/, /hotfix[\/\-_]/,
  /issue[\/\-_]/, /patch[\/\-_]/
];

if (bugPatterns.some(pattern => branchName.match(pattern))) {
  
  // Create Bug Task with High Priority
  const bugTask = await mcp.call('create_task', {
    title: `Bug Fix: ${extractBugTitle()}`,
    description: `Fix for: ${getBugDescription()}`,
    priority: "urgent",
    projectId: getCurrentProjectId(),
    tags: ["bug", "hotfix", "critical"],
    estimatedHours: 4
  });
  
  // Analyze Bug Complexity
  await mcp.call('analyze_complexity', {
    taskDescription: bugTask.description,
    context: `Bug fix in ${getCurrentFilePath()}`,
    includeRecommendations: true
  });
  
  // Set Up Bug Tracking
  await mcp.call('update_task', {
    taskId: bugTask.id,
    metadata: {
      bugType: classifyBugType(),
      severity: assessBugSeverity(),
      affectedComponents: getAffectedComponents()
    }
  });
}
```

### Workflow 3: Code Refactoring
**Trigger**: Refactoring existing code
**Automation Sequence**:

```typescript
// Refactoring Detection
if (commitMessage.includes('refactor') || 
    branchName.includes('refactor') ||
    detectLargeCodeChanges()) {
  
  // Create Refactoring Task
  const refactorTask = await mcp.call('create_task', {
    title: `Refactor: ${getRefactorScope()}`,
    description: `Code refactoring for ${getTargetComponent()}`,
    priority: "medium",
    projectId: getCurrentProjectId(),
    tags: ["refactor", "improvement", "technical-debt"],
    estimatedHours: calculateRefactorTime()
  });
  
  // Analyze Current Code Complexity
  const complexityBefore = await mcp.call('analyze_complexity', {
    taskDescription: `Pre-refactor analysis of ${getCurrentFile()}`,
    context: getFileContext(),
    includeRecommendations: true
  });
  
  // Set Refactoring Goals
  await mcp.call('update_task', {
    taskId: refactorTask.id,
    metadata: {
      complexityBefore: complexityBefore.score,
      targetComplexity: complexityBefore.score * 0.7, // 30% improvement
      refactorType: getRefactorType()
    }
  });
}
```

### Workflow 4: Testing Implementation
**Trigger**: Writing or updating tests
**Automation Sequence**:

```typescript
// Test File Detection
if (fileName.includes('.test.') || 
    fileName.includes('.spec.') ||
    filePath.includes('/tests/')) {
  
  // Create Testing Task
  const testTask = await mcp.call('create_task', {
    title: `Testing: ${getTestSubject()}`,
    description: `Implement tests for ${getTargetComponent()}`,
    priority: "medium",
    projectId: getCurrentProjectId(),
    tags: ["testing", "qa", "coverage"],
    estimatedHours: 3
  });
  
  // Link to Related Feature Task
  const relatedTask = findRelatedFeatureTask();
  if (relatedTask) {
    await mcp.call('update_task', {
      taskId: testTask.id,
      parentId: relatedTask.id,
      dependencies: [relatedTask.id]
    });
  }
  
  // Set Testing Goals
  await mcp.call('update_task', {
    taskId: testTask.id,
    metadata: {
      testType: getTestType(), // unit, integration, e2e
      coverageTarget: 90,
      testFramework: getTestFramework()
    }
  });
}
```

## 📝 Documentation Workflow Rules

### Workflow 5: Documentation Updates
**Trigger**: Working on documentation files
**Automation Sequence**:

```typescript
// Documentation Detection
if (fileName.endsWith('.md') || 
    filePath.includes('/docs/') ||
    fileName === 'README.md') {
  
  // Create Documentation Task
  const docTask = await mcp.call('create_task', {
    title: `Documentation: ${getDocumentTitle()}`,
    description: `Update documentation for ${getDocumentScope()}`,
    priority: "low",
    projectId: getCurrentProjectId(),
    tags: ["documentation", "writing"],
    estimatedHours: 2
  });
  
  // Link to Related Development Tasks
  const relatedTasks = findRelatedDevelopmentTasks();
  if (relatedTasks.length > 0) {
    await mcp.call('update_task', {
      taskId: docTask.id,
      dependencies: relatedTasks.map(t => t.id)
    });
  }
}
```

## 🔄 Git Integration Workflow Rules

### Workflow 6: Commit-Based Task Updates
**Trigger**: Making commits
**Automation Sequence**:

```typescript
// On Commit Event
onCommit(async (commitData) => {
  const { message, files, additions, deletions } = commitData;
  
  // Find Related Tasks
  const relatedTasks = await findTasksForFiles(files);
  
  for (const task of relatedTasks) {
    // Update Task Progress
    const progress = calculateProgressFromCommit(task, commitData);
    
    await mcp.call('update_task', {
      taskId: task.id,
      progress: progress,
      notes: `Commit: ${message}`,
      metadata: {
        lastCommit: commitData.hash,
        linesAdded: additions,
        linesDeleted: deletions
      }
    });
    
    // Check if Task is Complete
    if (progress >= 100) {
      await mcp.call('update_task', {
        taskId: task.id,
        status: "completed",
        completedAt: new Date().toISOString()
      });
    }
  }
});
```

### Workflow 7: Pull Request Workflow
**Trigger**: Creating or updating pull requests
**Automation Sequence**:

```typescript
// On Pull Request Creation
onPullRequest(async (prData) => {
  const { title, description, files, branch } = prData;
  
  // Find Related Tasks
  const relatedTasks = await findTasksForBranch(branch);
  
  for (const task of relatedTasks) {
    // Mark Task as Ready for Review
    await mcp.call('update_task', {
      taskId: task.id,
      status: "review",
      notes: `PR created: ${title}`,
      metadata: {
        pullRequestUrl: prData.url,
        reviewers: prData.reviewers
      }
    });
  }
  
  // Create Review Task if Needed
  if (prData.reviewers.length > 0) {
    await mcp.call('create_task', {
      title: `Code Review: ${title}`,
      description: `Review PR: ${description}`,
      priority: "high",
      projectId: getCurrentProjectId(),
      tags: ["review", "qa"],
      estimatedHours: 2,
      assignees: prData.reviewers
    });
  }
});
```

## ⏰ Time-Based Workflow Rules

### Workflow 8: Daily Standup Preparation
**Trigger**: Start of work day (configurable time)
**Automation Sequence**:

```typescript
// Daily Standup Automation (9:00 AM)
scheduleDaily('09:00', async () => {
  
  // Get Yesterday's Completed Tasks
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  
  const completedTasks = await mcp.call('list_tasks', {
    status: "completed",
    completedAfter: yesterday.toISOString(),
    limit: 10
  });
  
  // Get Today's Planned Tasks
  const todayTasks = await mcp.call('list_tasks', {
    status: "in_progress",
    priority: ["high", "urgent"],
    limit: 5
  });
  
  // Recalculate Priorities
  for (const task of todayTasks.tasks) {
    await mcp.call('calculate_priority', {
      taskId: task.id,
      factors: {
        urgency: getDeadlineUrgency(task),
        importance: getBusinessValue(task),
        effort: task.estimatedHours,
        dependencies: task.dependencies?.length || 0
      }
    });
  }
  
  // Generate Standup Report
  generateStandupReport(completedTasks, todayTasks);
});
```

### Workflow 9: Weekly Sprint Planning
**Trigger**: Weekly (configurable day/time)
**Automation Sequence**:

```typescript
// Weekly Sprint Planning (Monday 10:00 AM)
scheduleWeekly('monday', '10:00', async () => {
  
  // Get System Status and Metrics
  const systemStatus = await mcp.call('get_system_status', {
    includeMetrics: true,
    includeAnalytics: true
  });
  
  // Get All Pending Tasks
  const pendingTasks = await mcp.call('list_tasks', {
    status: ["pending", "in_progress"],
    limit: 50
  });
  
  // Recalculate All Priorities
  for (const task of pendingTasks.tasks) {
    await mcp.call('calculate_priority', {
      taskId: task.id
    });
  }
  
  // Analyze Sprint Capacity
  const sprintCapacity = calculateSprintCapacity(systemStatus.metrics);
  
  // Generate Sprint Plan
  generateSprintPlan(pendingTasks, sprintCapacity);
});
```

## 🎯 Context-Aware Workflow Rules

### Workflow 10: File-Based Context Rules
**Trigger**: Opening or working on specific files
**Automation Sequence**:

```typescript
// File Context Detection
onFileOpen(async (filePath) => {
  
  // Get File-Related Tasks
  const relatedTasks = await findTasksForFile(filePath);
  
  if (relatedTasks.length === 0) {
    // No existing tasks, check if we should create one
    if (shouldCreateTaskForFile(filePath)) {
      
      const fileTask = await mcp.call('create_task', {
        title: `Work on ${getFileName(filePath)}`,
        description: `Development work on ${filePath}`,
        priority: "medium",
        projectId: getCurrentProjectId(),
        tags: [getFileType(filePath), "development"],
        estimatedHours: estimateTimeForFile(filePath)
      });
      
      // Analyze File Complexity
      await mcp.call('analyze_complexity', {
        taskDescription: `Analysis of ${filePath}`,
        context: getFileContext(filePath),
        includeRecommendations: true
      });
    }
  } else {
    // Update existing task with current work session
    await mcp.call('update_task', {
      taskId: relatedTasks[0].id,
      notes: `Working on ${filePath}`,
      metadata: {
        lastWorkedOn: new Date().toISOString(),
        currentFile: filePath
      }
    });
  }
});
```

### Workflow 11: Project Context Rules
**Trigger**: Switching between projects
**Automation Sequence**:

```typescript
// Project Switch Detection
onProjectSwitch(async (newProjectId, oldProjectId) => {
  
  // Save Current Work State
  if (oldProjectId) {
    const activeTasks = await mcp.call('list_tasks', {
      projectId: oldProjectId,
      status: "in_progress"
    });
    
    for (const task of activeTasks.tasks) {
      await mcp.call('update_task', {
        taskId: task.id,
        metadata: {
          lastWorkedOn: new Date().toISOString(),
          workSession: calculateWorkSession(task)
        }
      });
    }
  }
  
  // Load New Project Context
  if (newProjectId) {
    // Get Project Status
    const projectTasks = await mcp.call('list_tasks', {
      projectId: newProjectId,
      status: ["in_progress", "pending"],
      limit: 10
    });
    
    // Recalculate Priorities for New Context
    for (const task of projectTasks.tasks) {
      await mcp.call('calculate_priority', {
        taskId: task.id
      });
    }
    
    // Show Project Dashboard
    showProjectDashboard(projectTasks);
  }
});
```

## 🔧 Configuration and Setup

### Workflow Configuration
```typescript
// Workflow Configuration Object
const workflowConfig = {
  autoTaskCreation: true,
  autoProgressTracking: true,
  autoPriorityCalculation: true,
  dailyStandupTime: "09:00",
  weeklyPlanningDay: "monday",
  weeklyPlanningTime: "10:00",
  complexityThreshold: 200, // lines of code
  estimationAccuracy: 0.8,
  defaultEstimates: {
    feature: 16,
    bug: 4,
    refactor: 8,
    test: 3,
    documentation: 2
  }
};
```

### Helper Functions
```typescript
// Utility Functions for Workflow Rules
function getCurrentProjectId(): string {
  return workspace.getConfiguration('aai.project.id') || 'default';
}

function extractFeatureName(branchName: string): string {
  return branchName.replace(/^(feature|feat)\//, '').replace(/[-_]/g, ' ');
}

function calculateEstimatedHours(fileSize: number, complexity: number): number {
  const baseHours = Math.ceil(fileSize / 100); // 1 hour per 100 lines
  const complexityMultiplier = 1 + (complexity / 10);
  return Math.min(baseHours * complexityMultiplier, 40); // Max 40 hours
}

function shouldCreateTaskForFile(filePath: string): boolean {
  const excludePatterns = [
    /node_modules/, /\.git/, /dist/, /build/,
    /\.log$/, /\.tmp$/, /\.cache/
  ];
  return !excludePatterns.some(pattern => pattern.test(filePath));
}
```

---

**These workflow automation rules ensure that task management is seamlessly integrated into every aspect of your development process, making project tracking effortless and intelligent.** 