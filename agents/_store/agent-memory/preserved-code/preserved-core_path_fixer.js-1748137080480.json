{
  "id": "preserved-core_path_fixer.js-1748137080480",
  "type": "preserved-code",
  "content": "#!/usr/bin/env node\n\n/**\n * ðŸ”§ Core Path Fixer\n * \n * Comprehensive fixer to resolve all corrupt, obsolete, and broken path patterns\n * in agents/_store/projects/_core content after migration\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\n\nclass CorePathFixer {\n  constructor() {\n    this.coreDir = 'agents/_store/projects/_core';\n    this.rulesDir = path.join(this.coreDir, 'rules');\n    this.backupDir = `backups/core-path-fix-${new Date().toISOString().replace(/[:.]/g, '-')}`;\n    this.results = {\n      filesProcessed: 0,\n      filesFixed: 0,\n      totalFixes: 0,\n      obsoletePathsFixed: 0,\n      corruptPathsFixed: 0,\n      brokenLinksFixed: 0,\n      selfReferencesRemoved: 0,\n      missingFilesHandled: 0,\n      errors: []\n    };\n  }\n\n  /**\n   * Run comprehensive fixing\n   */\n  async fix() {\n    console.log('ðŸ”§ CORE PATH FIXER');\n    console.log('â”'.repeat(60));\n    console.log(`ðŸ“ Fixing paths in: ${this.coreDir}`);\n    console.log('');\n\n    try {\n      // Create backup\n      await this.createBackup();\n      \n      // Get all .mdc files\n      const mdcFiles = await this.getAllMdcFiles();\n      console.log(`ðŸ“„ Found ${mdcFiles.length} .mdc files to fix`);\n      console.log('');\n\n      // Fix each file\n      for (const filePath of mdcFiles) {\n        await this.fixFile(filePath);\n      }\n\n      // Generate report\n      await this.generateReport();\n      \n      return this.results;\n\n    } catch (error) {\n      console.error('âŒ Fixing failed:', error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Create backup of all files before fixing\n   */\n  async createBackup() {\n    console.log('ðŸ“¦ Creating backup...');\n    \n    // Ensure backup directory exists\n    await fs.mkdir(this.backupDir, { recursive: true });\n    \n    // Copy entire _core directory\n    await this.copyDirectory(this.coreDir, path.join(this.backupDir, 'agents/_store/projects/_core'));\n    \n    console.log(`âœ… Backup created: ${this.backupDir}`);\n    console.log('');\n  }\n\n  /**\n   * Copy directory recursively\n   */\n  async copyDirectory(src, dest) {\n    await fs.mkdir(dest, { recursive: true });\n    const entries = await fs.readdir(src, { withFileTypes: true });\n    \n    for (const entry of entries) {\n      const srcPath = path.join(src, entry.name);\n      const destPath = path.join(dest, entry.name);\n      \n      if (entry.isDirectory()) {\n        await this.copyDirectory(srcPath, destPath);\n      } else {\n        await fs.copyFile(srcPath, destPath);\n      }\n    }\n  }\n\n  /**\n   * Get all .mdc files recursively\n   */\n  async getAllMdcFiles() {\n    const files = [];\n    \n    const scanDirectory = async (dir) => {\n      try {\n        const entries = await fs.readdir(dir, { withFileTypes: true });\n        \n        for (const entry of entries) {\n          const fullPath = path.join(dir, entry.name);\n          \n          if (entry.isDirectory()) {\n            await scanDirectory(fullPath);\n          } else if (entry.isFile() && entry.name.endsWith('.mdc')) {\n            files.push(fullPath);\n          }\n        }\n      } catch (error) {\n        console.warn(`âš ï¸ Could not scan directory ${dir}: ${error.message}`);\n      }\n    };\n\n    await scanDirectory(this.coreDir);\n    return files;\n  }\n\n  /**\n   * Fix a single file\n   */\n  async fixFile(filePath) {\n    try {\n      const relativePath = path.relative(this.coreDir, filePath);\n      const filename = path.basename(filePath);\n      console.log(`ðŸ”§ Fixing: ${relativePath}`);\n\n      let content = await fs.readFile(filePath, 'utf8');\n      const originalContent = content;\n      this.results.filesProcessed++;\n\n      let fixCount = 0;\n\n      // 1. Fix obsolete .cursor paths\n      const cursorFixes = this.fixObsoleteCursorPaths(content, filePath);\n      content = cursorFixes.content;\n      fixCount += cursorFixes.fixes;\n      this.results.obsoletePathsFixed += cursorFixes.fixes;\n\n      // 2. Fix broken absolute paths\n      const absoluteFixes = this.fixBrokenAbsolutePaths(content, filePath);\n      content = absoluteFixes.content;\n      fixCount += absoluteFixes.fixes;\n      this.results.corruptPathsFixed += absoluteFixes.fixes;\n\n      // 3. Remove self-references\n      const selfRefFixes = this.removeSelfReferences(content, filename);\n      content = selfRefFixes.content;\n      fixCount += selfRefFixes.fixes;\n      this.results.selfReferencesRemoved += selfRefFixes.fixes;\n\n      // 4. Fix broken links\n      const linkFixes = this.fixBrokenLinks(content);\n      content = linkFixes.content;\n      fixCount += linkFixes.fixes;\n      this.results.brokenLinksFixed += linkFixes.fixes;\n\n      // 5. Clean redundant paths\n      const redundantFixes = this.cleanRedundantPaths(content);\n      content = redundantFixes.content;\n      fixCount += redundantFixes.fixes;\n\n      // 6. Fix missing file references (create placeholder if needed)\n      const missingFixes = await this.handleMissingFiles(content, filePath);\n      content = missingFixes.content;\n      fixCount += missingFixes.fixes;\n      this.results.missingFilesHandled += missingFixes.fixes;\n\n      // 7. Final cleanup\n      content = this.finalCleanup(content);\n\n      // Save if changes were made\n      if (content !== originalContent) {\n        await fs.writeFile(filePath, content);\n        console.log(`  âœ… Fixed ${relativePath} (${fixCount} fixes)`);\n        this.results.filesFixed++;\n        this.results.totalFixes += fixCount;\n      } else {\n        console.log(`  âšª No changes needed for ${relativePath}`);\n      }\n\n    } catch (error) {\n      console.error(`  âŒ Error fixing ${filePath}: ${error.message}`);\n      this.results.errors.push({ file: filePath, error: error.message });\n    }\n  }\n\n  /**\n   * Fix obsolete .cursor path patterns\n   */\n  fixObsoleteCursorPaths(content, currentFilePath) {\n    let fixes = 0;\n    const currentDir = path.dirname(currentFilePath);\n    \n    // Fix .cursor/rules/ in links\n    content = content.replace(/\\[([^\\]]+)\\]\\(\\.cursor\\/rules\\/([^)]+)\\)/g, (match, text, targetPath) => {\n      const relativePath = this.calculateRelativePath(currentDir, targetPath);\n      fixes++;\n      console.log(`    ðŸ”„ .cursor link: ${match} â†’ [${text}](${relativePath})`);\n      return `[${text}](${relativePath})`;\n    });\n\n    // Fix standalone .cursor/rules/ references\n    content = content.replace(/\\.cursor\\/rules\\/([^\\s\\)\\]\\,\\;]+)/g, (match, targetPath) => {\n      const relativePath = this.calculateRelativePath(currentDir, targetPath);\n      fixes++;\n      console.log(`    ðŸ”„ .cursor path: ${match} â†’ ${relativePath}`);\n      return relativePath;\n    });\n\n    // Fix backtick-wrapped .cursor paths\n    content = content.replace(/`\\.cursor\\/rules\\/([^`]+)`/g, (match, targetPath) => {\n      const relativePath = this.calculateRelativePath(currentDir, targetPath);\n      fixes++;\n      console.log(`    ðŸ”„ .cursor backtick: ${match} â†’ \\`${relativePath}\\``);\n      return `\\`${relativePath}\\``;\n    });\n\n    return { content, fixes };\n  }\n\n  /**\n   * Fix broken absolute paths\n   */\n  fixBrokenAbsolutePaths(content, currentFilePath) {\n    let fixes = 0;\n    const currentDir = path.dirname(currentFilePath);\n    \n    // Fix absolute paths in links\n    content = content.replace(/\\[([^\\]]+)\\]\\(agents\\/_store\\/projects\\/_core\\/rules\\/([^)]+)\\)/g, (match, text, targetPath) => {\n      const relativePath = this.calculateRelativePath(currentDir, targetPath);\n      fixes++;\n      console.log(`    ðŸ”„ Absolute link: ${match} â†’ [${text}](${relativePath})`);\n      return `[${text}](${relativePath})`;\n    });\n\n    // Fix standalone absolute paths\n    content = content.replace(/agents\\/_store\\/projects\\/_core\\/rules\\/([^\\s\\)\\]\\,\\;]+)/g, (match, targetPath) => {\n      const relativePath = this.calculateRelativePath(currentDir, targetPath);\n      fixes++;\n      console.log(`    ðŸ”„ Absolute path: ${match} â†’ ${relativePath}`);\n      return relativePath;\n    });\n\n    return { content, fixes };\n  }\n\n  /**\n   * Remove self-references\n   */\n  removeSelfReferences(content, filename) {\n    let fixes = 0;\n\n    /",
  "metadata": {
    "content": "#!/usr/bin/env node\n\n/**\n * ðŸ”§ Core Path Fixer\n * \n * Comprehensive fixer to resolve all corrupt, obsolete, and broken path patterns\n * in agents/_store/projects/_core content after migration\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\n\nclass CorePathFixer {\n  constructor() {\n    this.coreDir = 'agents/_store/projects/_core';\n    this.rulesDir = path.join(this.coreDir, 'rules');\n    this.backupDir = `backups/core-path-fix-${new Date().toISOString().replace(/[:.]/g, '-')}`;\n    this.results = {\n      filesProcessed: 0,\n      filesFixed: 0,\n      totalFixes: 0,\n      obsoletePathsFixed: 0,\n      corruptPathsFixed: 0,\n      brokenLinksFixed: 0,\n      selfReferencesRemoved: 0,\n      missingFilesHandled: 0,\n      errors: []\n    };\n  }\n\n  /**\n   * Run comprehensive fixing\n   */\n  async fix() {\n    console.log('ðŸ”§ CORE PATH FIXER');\n    console.log('â”'.repeat(60));\n    console.log(`ðŸ“ Fixing paths in: ${this.coreDir}`);\n    console.log('');\n\n    try {\n      // Create backup\n      await this.createBackup();\n      \n      // Get all .mdc files\n      const mdcFiles = await this.getAllMdcFiles();\n      console.log(`ðŸ“„ Found ${mdcFiles.length} .mdc files to fix`);\n      console.log('');\n\n      // Fix each file\n      for (const filePath of mdcFiles) {\n        await this.fixFile(filePath);\n      }\n\n      // Generate report\n      await this.generateReport();\n      \n      return this.results;\n\n    } catch (error) {\n      console.error('âŒ Fixing failed:', error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Create backup of all files before fixing\n   */\n  async createBackup() {\n    console.log('ðŸ“¦ Creating backup...');\n    \n    // Ensure backup directory exists\n    await fs.mkdir(this.backupDir, { recursive: true });\n    \n    // Copy entire _core directory\n    await this.copyDirectory(this.coreDir, path.join(this.backupDir, 'agents/_store/projects/_core'));\n    \n    console.log(`âœ… Backup created: ${this.backupDir}`);\n    console.log('');\n  }\n\n  /**\n   * Copy directory recursively\n   */\n  async copyDirectory(src, dest) {\n    await fs.mkdir(dest, { recursive: true });\n    const entries = await fs.readdir(src, { withFileTypes: true });\n    \n    for (const entry of entries) {\n      const srcPath = path.join(src, entry.name);\n      const destPath = path.join(dest, entry.name);\n      \n      if (entry.isDirectory()) {\n        await this.copyDirectory(srcPath, destPath);\n      } else {\n        await fs.copyFile(srcPath, destPath);\n      }\n    }\n  }\n\n  /**\n   * Get all .mdc files recursively\n   */\n  async getAllMdcFiles() {\n    const files = [];\n    \n    const scanDirectory = async (dir) => {\n      try {\n        const entries = await fs.readdir(dir, { withFileTypes: true });\n        \n        for (const entry of entries) {\n          const fullPath = path.join(dir, entry.name);\n          \n          if (entry.isDirectory()) {\n            await scanDirectory(fullPath);\n          } else if (entry.isFile() && entry.name.endsWith('.mdc')) {\n            files.push(fullPath);\n          }\n        }\n      } catch (error) {\n        console.warn(`âš ï¸ Could not scan directory ${dir}: ${error.message}`);\n      }\n    };\n\n    await scanDirectory(this.coreDir);\n    return files;\n  }\n\n  /**\n   * Fix a single file\n   */\n  async fixFile(filePath) {\n    try {\n      const relativePath = path.relative(this.coreDir, filePath);\n      const filename = path.basename(filePath);\n      console.log(`ðŸ”§ Fixing: ${relativePath}`);\n\n      let content = await fs.readFile(filePath, 'utf8');\n      const originalContent = content;\n      this.results.filesProcessed++;\n\n      let fixCount = 0;\n\n      // 1. Fix obsolete .cursor paths\n      const cursorFixes = this.fixObsoleteCursorPaths(content, filePath);\n      content = cursorFixes.content;\n      fixCount += cursorFixes.fixes;\n      this.results.obsoletePathsFixed += cursorFixes.fixes;\n\n      // 2. Fix broken absolute paths\n      const absoluteFixes = this.fixBrokenAbsolutePaths(content, filePath);\n      content = absoluteFixes.content;\n      fixCount += absoluteFixes.fixes;\n      this.results.corruptPathsFixed += absoluteFixes.fixes;\n\n      // 3. Remove self-references\n      const selfRefFixes = this.removeSelfReferences(content, filename);\n      content = selfRefFixes.content;\n      fixCount += selfRefFixes.fixes;\n      this.results.selfReferencesRemoved += selfRefFixes.fixes;\n\n      // 4. Fix broken links\n      const linkFixes = this.fixBrokenLinks(content);\n      content = linkFixes.content;\n      fixCount += linkFixes.fixes;\n      this.results.brokenLinksFixed += linkFixes.fixes;\n\n      // 5. Clean redundant paths\n      const redundantFixes = this.cleanRedundantPaths(content);\n      content = redundantFixes.content;\n      fixCount += redundantFixes.fixes;\n\n      // 6. Fix missing file references (create placeholder if needed)\n      const missingFixes = await this.handleMissingFiles(content, filePath);\n      content = missingFixes.content;\n      fixCount += missingFixes.fixes;\n      this.results.missingFilesHandled += missingFixes.fixes;\n\n      // 7. Final cleanup\n      content = this.finalCleanup(content);\n\n      // Save if changes were made\n      if (content !== originalContent) {\n        await fs.writeFile(filePath, content);\n        console.log(`  âœ… Fixed ${relativePath} (${fixCount} fixes)`);\n        this.results.filesFixed++;\n        this.results.totalFixes += fixCount;\n      } else {\n        console.log(`  âšª No changes needed for ${relativePath}`);\n      }\n\n    } catch (error) {\n      console.error(`  âŒ Error fixing ${filePath}: ${error.message}`);\n      this.results.errors.push({ file: filePath, error: error.message });\n    }\n  }\n\n  /**\n   * Fix obsolete .cursor path patterns\n   */\n  fixObsoleteCursorPaths(content, currentFilePath) {\n    let fixes = 0;\n    const currentDir = path.dirname(currentFilePath);\n    \n    // Fix .cursor/rules/ in links\n    content = content.replace(/\\[([^\\]]+)\\]\\(\\.cursor\\/rules\\/([^)]+)\\)/g, (match, text, targetPath) => {\n      const relativePath = this.calculateRelativePath(currentDir, targetPath);\n      fixes++;\n      console.log(`    ðŸ”„ .cursor link: ${match} â†’ [${text}](${relativePath})`);\n      return `[${text}](${relativePath})`;\n    });\n\n    // Fix standalone .cursor/rules/ references\n    content = content.replace(/\\.cursor\\/rules\\/([^\\s\\)\\]\\,\\;]+)/g, (match, targetPath) => {\n      const relativePath = this.calculateRelativePath(currentDir, targetPath);\n      fixes++;\n      console.log(`    ðŸ”„ .cursor path: ${match} â†’ ${relativePath}`);\n      return relativePath;\n    });\n\n    // Fix backtick-wrapped .cursor paths\n    content = content.replace(/`\\.cursor\\/rules\\/([^`]+)`/g, (match, targetPath) => {\n      const relativePath = this.calculateRelativePath(currentDir, targetPath);\n      fixes++;\n      console.log(`    ðŸ”„ .cursor backtick: ${match} â†’ \\`${relativePath}\\``);\n      return `\\`${relativePath}\\``;\n    });\n\n    return { content, fixes };\n  }\n\n  /**\n   * Fix broken absolute paths\n   */\n  fixBrokenAbsolutePaths(content, currentFilePath) {\n    let fixes = 0;\n    const currentDir = path.dirname(currentFilePath);\n    \n    // Fix absolute paths in links\n    content = content.replace(/\\[([^\\]]+)\\]\\(agents\\/_store\\/projects\\/_core\\/rules\\/([^)]+)\\)/g, (match, text, targetPath) => {\n      const relativePath = this.calculateRelativePath(currentDir, targetPath);\n      fixes++;\n      console.log(`    ðŸ”„ Absolute link: ${match} â†’ [${text}](${relativePath})`);\n      return `[${text}](${relativePath})`;\n    });\n\n    // Fix standalone absolute paths\n    content = content.replace(/agents\\/_store\\/projects\\/_core\\/rules\\/([^\\s\\)\\]\\,\\;]+)/g, (match, targetPath) => {\n      const relativePath = this.calculateRelativePath(currentDir, targetPath);\n      fixes++;\n      console.log(`    ðŸ”„ Absolute path: ${match} â†’ ${relativePath}`);\n      return relativePath;\n    });\n\n    return { content, fixes };\n  }\n\n  /**\n   * Remove self-references\n   */\n  removeSelfReferences(content, filename) {\n    let fixes = 0;\n\n    /",
    "description": "No description available",
    "filename": "core_path_fixer.js",
    "functions": "CorePathFixer",
    "keyFeatures": "Object-Oriented, Async/Await, File System, Path Manipulation, Process Management, Logging, JSON Processing, Regular Expressions",
    "originalPath": "agents/_store/projects/core_path_fixer.js",
    "preservedAt": "2025-05-25T01:35:35.668Z",
    "size": 15597,
    "timestamp": "2025-05-25T01:38:00.480Z",
    "type": "preserved-code"
  },
  "embedding": []
}