---
description:
globs:
alwaysApply: false
---
# ğŸ¤– Agent AI System - Core Architecture & Implementation

*Advanced AI development assistant with memory, dependency tracking, and intelligent project management*

## ğŸ—ï¸ System Architecture Overview

The Agent AI System is built with a sophisticated modular architecture designed for scalability, reliability, and universal compatibility:

### **ğŸ“ Core Directory Structure**
```
agents/
â”œâ”€â”€ _store/                          # Organized data storage
â”‚   â”œâ”€â”€ docs/                       # System documentation
â”‚   â”œâ”€â”€ project-memory/              # Project-specific memories
â”‚   â”œâ”€â”€ dependencies/                # File dependency tracking
â”‚   â””â”€â”€ backups/                     # Safety backups
â”œâ”€â”€ self-improvement/                # Core agent modules
â”‚   â”œâ”€â”€ core/                       # Core functionality
â”‚   â”œâ”€â”€ config/                     # Configuration management
â”‚   â”œâ”€â”€ memory/                     # Memory system
â”‚   â”œâ”€â”€ dependencies/               # Dependency tracking
â”‚   â””â”€â”€ projects/                   # Project management
â””â”€â”€ package.json                    # npm scripts and dependencies
```

### **âš™ï¸ Core System Components**

#### 1. **ğŸ§  Advanced Memory System**
```javascript
/ Vector-based memory with Pinecone integration
class MemorySystem {
  constructor() {
    this.vectorStore = new PineconeStore();
    this.localFallback = new LocalMemoryStore();
    this.similarityThreshold = 0.8;
  }

  async storeMemory(content, metadata) {
    / Store in both vector database and local fallback
    await this.vectorStore.store(content, metadata);
    await this.localFallback.store(content, metadata);
  }

  async searchSimilar(query, limit = 10) {
    try {
      / Try Pinecone first for advanced similarity search
      return await this.vectorStore.search(query, limit);
    } catch (error) {
      / Fallback to local search
      return await this.localFallback.search(query, limit);
    }
  }
}
```

#### 2. **ğŸ”— File Dependency Tracking**
```javascript
/ Real-time file dependency monitoring
class DependencyTracker {
  constructor() {
    this.dependencyGraph = new Map();
    this.fileWatcher = new FileWatcher();
    this.analysisEngine = new DependencyAnalysisEngine();
  }

  async analyzeDependencies(filePath) {
    const dependencies = await this.analysisEngine.analyze(filePath);
    this.updateDependencyGraph(filePath, dependencies);
    return {
      direct: dependencies.direct,
      indirect: dependencies.indirect,
      circular: dependencies.circular,
      impact: this.calculateImpact(filePath)
    };
  }

  async getCascadeImpact(filePath) {
    / Calculate what files would be affected by changes
    const affected = new Set();
    this.traverseDependents(filePath, affected);
    return Array.from(affected);
  }
}
```

#### 3. **ğŸ“ Multi-Project Management**
```javascript
/ Intelligent project context management
class ProjectManager {
  constructor() {
    this.activeProject = null;
    this.projectContexts = new Map();
    this.crossProjectLearning = new CrossProjectLearning();
  }

  async switchProject(projectName) {
    / Save current context
    if (this.activeProject) {
      await this.saveProjectContext(this.activeProject);
    }

    / Load new project context
    this.activeProject = projectName;
    const context = await this.loadProjectContext(projectName);
    this.applyProjectContext(context);
  }

  async getProjectInsights(projectName) {
    const project = this.projectContexts.get(projectName);
    return {
      patterns: project.learnedPatterns,
      preferences: project.userPreferences,
      commonIssues: project.commonIssues,
      successfulSolutions: project.successfulSolutions
    };
  }
}
```

## ğŸ¯ Advanced Analysis Engine

### **ğŸ” Context-Aware Pattern Detection**
```javascript
class AdvancedAnalysisEngine {
  constructor() {
    this.patternLibrary = new PatternLibrary();
    this.contextAnalyzer = new ContextAnalyzer();
    this.learningEngine = new LearningEngine();
  }

  async analyzeFile(filePath, context = {}) {
    const analysis = {
      patterns: await this.detectPatterns(filePath),
      dependencies: await this.analyzeDependencies(filePath),
      quality: await this.assessQuality(filePath),
      improvements: await this.generateImprovements(filePath, context),
      contextualRelevance: await this.assessContextualRelevance(filePath, context)
    };

    / Learn from analysis for future improvements
    await this.learningEngine.learn(analysis);
    return analysis;
  }

  async smartDetect(workflowPhase) {
    / Context-aware file detection based on current workflow phase
    const relevantFiles = await this.contextAnalyzer.findRelevantFiles(workflowPhase);
    const analysisResults = [];

    for (const file of relevantFiles) {
      const analysis = await this.analyzeFile(file, { phase: workflowPhase });
      if (analysis.contextualRelevance > 0.7) {
        analysisResults.push(analysis);
      }
    }

    return this.prioritizeResults(analysisResults);
  }
}
```

### **ğŸ§  Learning & Adaptation System**
```javascript
class LearningEngine {
  constructor() {
    this.userFeedbackHistory = [];
    this.patternSuccessRates = new Map();
    this.adaptiveWeights = new Map();
  }

  async learn(feedback) {
    / Update pattern recognition based on user feedback
    this.updatePatternWeights(feedback);

    / Adapt suggestion confidence scores
    this.adjustConfidenceScores(feedback);

    / Build user preference profile
    this.updateUserProfile(feedback);

    / Cross-project pattern learning
    this.updateCrossProjectPatterns(feedback);
  }

  async generateContextualSuggestions(context) {
    const patterns = this.getRelevantPatterns(context);
    const userPreferences = this.getUserPreferences(context);

    return this.synthesizeSuggestions(patterns, userPreferences, context);
  }
}
```

## ğŸ® Command System Architecture

### **ğŸ“‹ Comprehensive Command Interface**
```javascript
class CommandSystem {
  constructor() {
    this.commands = new Map();
    this.registerCommands();
  }

  registerCommands() {
    / Analysis commands
    this.register('analyze', new AnalyzeCommand());
    this.register('improve', new ImproveCommand());
    this.register('smart-detect', new SmartDetectCommand());

    / Memory commands
    this.register('memory', new MemoryCommand());

    / Dependency commands
    this.register('dependencies', new DependencyCommand());

    / Project commands
    this.register('projects', new ProjectCommand());

    / System commands
    this.register('status', new StatusCommand());
    this.register('config', new ConfigCommand());
  }

  async execute(commandString) {
    const [command, ...args] = commandString.split(' ');
    const handler = this.commands.get(command);

    if (!handler) {
      return this.showHelp();
    }

    return await handler.execute(args);
  }
}
```

## ğŸ”§ Configuration & Environment Management

### **âš™ï¸ Adaptive Configuration System**
```json
/ agents/self-improvement/config/default.json
{
  "agent": {
    "memoryEnabled": true,
    "fileStoreEnabled": true,
    "dependencyTrackingEnabled": true,
    "learningEnabled": true,
    "crossProjectLearning": true
  },
  "memory": {
    "enablePinecone": true,
    "enableOpenAI": true,
    "maxLocalMemories": 1000,
    "similarityThreshold": 0.8,
    "autoCleanupDays": 30
  },
  "dependencies": {
    "realTimeMonitoring": true,
    "cascadeAnalysis": true,
    "circularDependencyDetection": true,
    "impactAssessment": true
  },
  "projects": {
    "autoSwitchContext": true,
    "trackCrossDependencies": true,
    "sharedLearning": true,
    "contextPersistence": true
  },
  "analysis": {
    "contextAwareDetection": true,
    "patternLearning": true,
    "qualityAssessment": true,
    "improvementGeneration": true
  }
}
```

### **ğŸŒ Environment Setup & Management**
```javascript
/ Interactive environment configuration
class EnvironmentManager {
  async setupEnvironment() {
    const config = await this.detectEnvironment();

    / Configure API keys (optional for enhanced features)
    if (config.pineconeAvailable) {
      await this.configurePinecone();
    }

    if (config.openaiAvailable) {
      await this.configureOpenAI();
    }

    / Set up project structure
    await this.initializeProjectStructure();

    / Configure npm scripts
    await this.setupNpmScripts();

    return config;
  }

  async validateEnvironment() {
    const checks = {
      coreSystem: await this.checkCoreSystem(),
      memorySystem: await this.checkMemorySystem(),
      dependencyTracking: await this.checkDependencyTracking(),
      projectManagement: await this.checkProjectManagement()
    };

    return {
      healthy: Object.values(checks).every(check => check.status === 'ok'),
      details: checks
    };
  }
}
```

## ğŸš€ NPM Scripts Integration

### **ğŸ“‹ Available Commands**
```json
/ package.json scripts
{
  "scripts": {
    "AAI:agent": "node agents/self-improvement/core/agent.js",
    "AAI:demo": "node agents/self-improvement/demo/demo.js",
    "AAI:setup-env": "node agents/self-improvement/setup/setup-env.js",
    "AAI:test-system": "node agents/self-improvement/tests/test-system.js",
    "AAI:test-dependencies": "node agents/self-improvement/tests/test-dependencies.js",
    "AAI:test-agent": "node agents/self-improvement/tests/test-agent.js",
    "AAI:legacy": "node agents/self-improvement/legacy/legacy-agent.js"
  }
}
```

## ğŸ¯ Integration with Development Workflow

### **ğŸ”„ Workflow Phase Integration**
```javascript
class WorkflowIntegration {
  constructor() {
    this.phaseHandlers = new Map();
    this.setupPhaseHandlers();
  }

  setupPhaseHandlers() {
    this.phaseHandlers.set('planning', new PlanningPhaseHandler());
    this.phaseHandlers.set('architecture', new ArchitecturePhaseHandler());
    this.phaseHandlers.set('implementation', new ImplementationPhaseHandler());
    this.phaseHandlers.set('testing', new TestingPhaseHandler());
    this.phaseHandlers.set('deployment', new DeploymentPhaseHandler());
  }

  async handlePhase(phase, context) {
    const handler = this.phaseHandlers.get(phase);
    if (!handler) return null;

    return await handler.process(context);
  }
}
```

## ğŸ›¡ï¸ Safety & Reliability Features

### **ğŸ”’ Comprehensive Safety System**
```javascript
class SafetySystem {
  constructor() {
    this.backupManager = new BackupManager();
    this.validationEngine = new ValidationEngine();
    this.rollbackSystem = new RollbackSystem();
  }

  async safeOperation(operation, context) {
    / Create backup before operation
    const backupId = await this.backupManager.createBackup(context);

    try {
      / Validate operation safety
      const validation = await this.validationEngine.validate(operation);
      if (!validation.safe) {
        throw new Error(`Unsafe operation: ${validation.reason}`);
      }

      / Execute operation
      const result = await operation.execute();

      / Validate result
      const resultValidation = await this.validationEngine.validateResult(result);
      if (!resultValidation.valid) {
        await this.rollbackSystem.rollback(backupId);
        throw new Error(`Invalid result: ${resultValidation.reason}`);
      }

      return result;
    } catch (error) {
      / Automatic rollback on failure
      await this.rollbackSystem.rollback(backupId);
      throw error;
    }
  }
}
```

## ğŸ¯ Future Evolution & Extensibility

### **ğŸ”® Planned Enhancements**
- **Advanced AI Model Integration**: Support for latest language models
- **Visual Dependency Graphs**: Interactive dependency visualization
- **Collaborative Learning**: Team-wide pattern sharing
- **Plugin Architecture**: Custom analysis modules
- **Real-time Collaboration**: Multi-developer context sharing

### **ğŸ”§ Extension Points**
```javascript
/ Plugin system for custom analyzers
class PluginSystem {
  constructor() {
    this.plugins = new Map();
  }

  registerPlugin(name, plugin) {
    this.plugins.set(name, plugin);
  }

  async executePlugins(context) {
    const results = [];
    for (const [name, plugin] of this.plugins) {
      try {
        const result = await plugin.execute(context);
        results.push({ plugin: name, result });
      } catch (error) {
        console.warn(`Plugin ${name} failed:`, error);
      }
    }
    return results;
  }
}
```

---

*ğŸ¯ This Agent AI System represents a sophisticated evolution in development assistance, combining advanced memory, intelligent dependency tracking, and adaptive learning to create a truly intelligent coding companion.*
